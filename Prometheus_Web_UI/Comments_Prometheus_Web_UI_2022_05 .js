{/*  ====  HTML  ====
    
    <html> - тег, состоит из имени тега и боковых скобок.

    <p>Tekst</p> - элемент, состоит из открывающего и закрывающего тегов и текста между ними.

    <a href='#' id='link'></a> - id - это аттрибут.

    head - вся информация про страницу, содержимое не отображается в браузере.

    body - главный контент страницы, содержимое отображается в браузере.



    ***  ЗАГОЛОВКИ И ФОРМАТИРОВАНИЕ ТЕКСТА

    <h1></h1>, h2, h3, h4, h5, h6 - заголовки - визуальное и логическое разделение информации по важности. Для обычного выделения
    текста заголовок не подходит (используем <b>/<strong>, <em>/<i>, <small>, <sup>, <sub>). Заголовки используются для логического
    выделения текста для поисковых систем.

    <p>Текст</p> - тег параграф служит обверткой для текста.

    <br> - служит для переноса далее следующего текста на новую строку.

    <b></b>, <strong></strong> - выделение жирным.

    <i></i>, <em></em> - выделение курсивом.

    <small></small> - уменьшение текста.

    <sup></sup> - делает текст надстрочным.

    <sub></sub> - делает текст подстрочным.

    <pre>                   -   показывает текст не убирая пробелы и переносы.
        текст
            с отступами
                и переносами
    </pre>

    <blockquote></blockquote> - выделение как цытаты.

    <mark></mark> - посдвечивает текст(как будто желтым маркером).

    ОПРЕДЕЛЕНИЕ
    <dl> - definition list
        <dt> - definition title
        HTML
        </dt>
        <dd> - definition description
        Hyper Text Markup Language 
        </dd>
    </dl>

    <abbr title="HyperText Markup Language">HTML</abbr>  - показывает содержимое title при наведении на текст(расшифровка аббревиатур)



    *** СПИСКИ

    Списки: маркированные - <ul></ul> и нумерованные <ol></ol>.  <li></li> - элемент списка.

    <ul>
        <li>Текст 1</li>
        <li>Текст 2</li>
        <li>Текст 3</li>
    </ul>

    <ol>
        <li>Номер 1</li>
        <li>Номер 2</li>
        <li>Номер 3</li>
    </ol>

    Вложенность

    <ol>
        <li>Номер 1</li>
        <li>Номер 2</li>
        <li>
            <ul>
                <li>Текст 1</li>
                <li>Текст 2</li>
            </ul>
        </li>
    </ol>



    *** ГИПЕРССЫЛКИ

    <a href='google.com'>Google</a> - может переходить по внешней ссылке.
    <a href='google.com' target='_blank'>Google</a> - с аттрибутом бланк, откроет ссылку в новом окне.

    <a href='#parag'>Ссылка на параграф с айди parag</a> - переходит к элементу с заданным айди.



    *** ВСТАВКА ИЗОБРАЖЕНИЙ

    <img src='./img/cat.jpg' alt='cat'> - вставит изображение которое находится в папке img с названием cat.jpg. Если картинка не 
    загрузится тогда на ее месте будет выводится текст из alt, также этот текст помогает поисковым система индексировать картинку.

    Также аттрибуты width и height - регулируют размер изображения. Обычно указывают только один параметр что бы изображение отобразилось
    пропорционально, также эти параметры резервируют место под картинку пока она не загрузилась, что бы не ломать верстку.

    <img src='./img/cat.jpg' alt='cat' height='300'>



    *** ТАБЛИЦЫ

    <table>
        <caption>Основной заголовок</caption>
        <thead>
            <tr>
                <td>Заголовок столбца 1</td>
                <td>Заголовок столбца 2</td>
                <td>Заголовок столбца 3</td>
                <td>Заголовок столбца 4</td>
            </tr>
        </thead>

        <tbody>
            <tr>
                <td>Текст</td>
                <td>Текст</td>
                <td>Текст</td>
                <td rowspan='2'>Текст</td> - объединили 2 колонки вертикально
            </tr>
            <tr>
                <td>Текст</td>
                <td>Текст</td>
                <td>Текст</td>
                эта ячейка поглощена роуспаном
            </tr>
        </tbody>

        <tfoot>
            <tr>
                <td>Текст</td>
                <td>Текст</td>
                <td colspan='2'>Текст</td> - объединили 2 колонки горизонтально
                эта ячейка поглощена колспаном
            </tr>
        </tfoot>
    </table>



    *** ФОРМЫ

    Тег форм обворачивает все инпуты. Нейм - имя формы, action - адресс скрипта который будет обрабатывать данные формы(куда отправляем),
    method - каким методом передается информация(POST - защищенный, GET - передает данные в адрессной строке).

    Вид инпута определяется значением в type.

    <form name='user_data' action='send.php' method='POST'> 
        <fieldset> - создает блок с обводкой вокруг элементов
        legend>Personal</legend> - видимое название блока с обводкой
        <label for='user_name'>Your name:</label>  - Текст перед полем. Для привязки(что бы по клику выбиралось нужное поле)
                                                                        используется аттрибут for по айди ***без хештега
        <input type='text' name='user_name' placeholder='Enter your name' id='user_name'>  - текстовое поле
        <br>
        <br>
        <label for='user_age'>Your age:</label>
        <input type='number' name='user_age' placeholder='Enter your age' id='user_age' required='true'> - числовое поле. 
                                            required - аттрибут указывает что нельзя отправлять форму без заполнения этого поля
        <br>
        <br>
        </fieldset>
        <label for='user_password'>Your password:</label>
        <input type='password' name='user_password' placeholder='Enter your password' id='user_password'> - поле для пароля, символы
        <br>                                                                                                закрываются звездочками.
        <br>
        <input type='radio' name='genre' value='male'>
        <input type='radio' name='genre' value='female'> - радио кнопки(круг), если name одинаковый то можно выбрать только один из них.                                                                                            
        <br>                                                                                                
        <br>
        <label for='remebmer'>Remebmer me:</label>
        <input type='checkbox' name='remebmer' id='remebmer'> - квадратик где можно ставить галочку(чекбокс).
        <br>                                                                                                
        <br>
        <select name='city'>   - выпадающий список
            <option value='Kyiv'>Kyiv</option>
            <option value='Lviv'>Lviv</option>
        </select>
        <br>                                                                                                
        <br>
        <label for='message'>Message:</label>
        <input type='textarea' name='message' id='message'>  - текстовое поле которое можно увеличивать.
        <br>                                                                                                
        <br>
        <input type='submit' value='Submitt'> - кнопка отправки формы, value - текст в середине кнопки.
    </form>



    *** БЛОЧНЫЕ И СТРОЧНЫЕ ЭЛЕМЕНТЫ

    БЛОЧНЫЕ - которые содержат блок информации и начинаются с новой строки по умолчанию(Заголовки, параграфы, теблицы, формы)

    СТРОЧНЫЕ - элементы форматирования текста которые находстя в самом тексте (strong, sub, sup, гиперссылки, картинки)

    <div>текст</div> - блочный элемент обвертка для любого содержимого. Занимает всю ширину страницы.

    <spanТекст</span><spanТекст</span> - строчный элемент(второй текст начинается сразу за первым в той же строчке) - используется для
    выделения части текста что бы ему можно было присвоить стили отличительные от используемых на странице.



    ***СЕМАНТИКА

    Семантика страницы нужна для правильного логического наполнения документа.
    Теги семантические 
    <header> - шапка сайта, 
    <footer>- подвал сайта, 
    <article> - статьи, формы, 
    <aside> - определяет блок сбоку для различный рубрик/архивов, 
    <section> - секция/раздел, может также быть с заголовком, 
    <main> - используется для основного документа, 
    <nav> - задает навигацию по сайту, если на странице несколько тегов со ссылками, то в нав помещают приоритетные,
    ...


    Мультимедиа

    В аудио добавляют файлы с разным кодированием что бы разные браузеры могли его воспроизвести. Controls - нужен для того что бы
    появились элементы управления воспроизведением.
    <audio controls>
        <source src='sound.ogg' type='audio/ogg'>
        <source src='sound.mp3' type='audio/mpeg'>
        Your browser does not support audio
    </audio>

    Видео - если браузер очень старый тогда вместо видео будет отображен текст - Your browser does not support video
    <video width='320' height='240' controls>
        <source src='movie.ogg' type='movie/ogg'>
        <source src='movie.mp4' type='movie/mp4'>
        Your browser does not support video
    </video>

*/}


{/*  ====  Создаем страницу только на ХТМЛ.  ====

    Анализируем макет и выделяем 4 основные блока которые у нас будут - это Хедер, главное меню с формой логина <nav>, основная
    часть <main> и футер.

    добавляем комментарии перед секциями.

    Так как контент находится по центру экрана с отступами от крае то нужно весь этот контент обернуть в тег div для последующего
    редактирования в ксс.

    Создаем хеер и наполняем текстом h1 и h2 теги.
    Так как контент находится по центру экрана с отступами от крае то нужно весь этот контент обернуть в тег div для последующего
    редактирования в ксс.

    Для тега nav нужно сделать 2 элемента. Также обернем весь контент в div. 
    Главное меню состоит из списка(почему список хз) из трех элементов, сделаем как маркированный список и также в каждом элементе
    должна быть ссылка.
    В этой же строке должна быть форма авторизации поэтому ниже списка добавим коментарий и форму.

    Также обернем весь контент в div.
    В главной секции main  есть две секции (коллекции с тайтлом(h2) и 3 элементами в каждом из которых есть картинка, тайтл(h3), 
    контент/параграф и кнопка) для видео и для картинок, тоесть можно сверстать одину а для второй скопировать.
    Карточки коллеции тоже будут завернуты в div, еще 1 div для каждой карточки и еще 1 для параграфа??(скажет когда будем проходить ксс)

    После построения карточки копируем ее два раза, потом коллекцию копируем и заменяем тайтл на видео и вместо картинки вставляем видео
    <video controls>
        <source src='./video/movie.mp4' type='video/mp4'>
    </video>

    Весрстаем футер. Он состоит из контейнера и параграфа.

*/}


{/*  ==== CSS  ====

    CSS -  каскадная таблица стилей (cascading style sheets).


    Правила написания  H1 - селектор, color - свойство,  green - значение.

    h1:{
        color: green;
    }

    Пропишем в файле Ксс такой код, что бы он применился к тегу р нужно его подключить к файлу индекс
    p{
        color: red; 
        font-size: 30px;
    }


    +++ Варианты подключения ксс кода

    1) inline стиль - добавление ксс конструкции в тег хтмл при помощи аттрибута style=""

    2) Сохранение ксс в теге <style></style> которые находится в <head>

    3) Код ксс помещам в отдельны файл и добавляем путь к нему через тег <link> находится в <head>

    4) @import

    Рассмотрим на примере: Поделим страницу на блоки header, aside, main, footer и увидим каким способом удобнее всего добавлять
    стили

    Пропишем эти теги, майдбар и мейн завернем в еще 1 див.
    Пропишем инлайн стили background-color для каждого блока и введем текст что бы они начали отображаться. Прописываем ширину 900px
    и высоту 150px, в див элементе только ширину. Высоту мейн и эсайд прописываем в них и делаем по 200px. Теперь осталось разместить
    блоки в правильном порядке. 

    text-align: center; для всех тегов для установки текста по центру блока.
    padding-top: 30px;  для каждого блока сделает внутренний отступ для содержимого блока0.
    margin: 10px auto; - внешние отступы псверху/снизу 10пкс слева/справ - auto - отцентрирует блок.
    width: 300px; float: left; - для блока эсайн сделает его ширину 300 пикселей из 900 общих, а флоат лефт(обтекание слева)
                                    поставит блок в левую часть, так как у мейн нету ширины, он займет оставшееся место.
    
    Как можно увидеть при использовании такого количества инлайн стилей очень ухудшается читабельность кода, поэтому опробуем второй
    метод, вынесем теги в тег <style type='text/css'> в теге <head>. Видим что по верстке ничего не изменилось, и хоть перенос
    помог сделать код верстки читабельным, но все же загромоздил пространство в хтмл файле, поэтому перенесем весь код ксс
    в отдельный файл который находится в папке ксс  ./css/block.css и подключим их в теге head
    <link rel="stylesheet" href="./css/block.css">

    Подключить стили при помощи @import можно так - удаляем link, вместо него:
    <style type='text/css'>@import url("./css/block.css");</style>
    *** Недостаток такого подключения в том что при подключении нескольких ксс файлов при импорте браузер может не придерживаться
    очередности их подгрузки, а очередность важна потому что подгружаются: 1) дефолтные стили браузера, 2) стили из тега style
    прописаном в head - они перекрывают дефолтные стили, 3) самые главные - инлайн стили.


    +++ СЕЛЕКТОРЫ

    Позволяет обратится к одному или нескольким конкретным хтмл елементам.
    Селекторы бывают: id, class, тег, аттрибут, *, псевдо-элемент, псевдо-класс 

    Для id и class название мы выбираем самостоятельно, что бы не было путаницы в большом проекте рекомендуют следовать таким советам
    *можно использовать латинские буквы, цифры и спец символы
    *название селектора должно отвечать(быть логичным) месту его использования
    *свои правила имен, нужно выбрать единый стиль которым называть селекторы и использовать его во всем проекте

    Обращение к хтмл элементам из ксс:
    
    по id <p id='paragraf_1'></p> - айди дожен быть уникальным в рамках одной хтмл страницы
    #paragraf_1 {} - обращение через хештег(#)

    по class <p class='paragraf_2'></p> - один класс можно присвоить нескольким елементам
    .paragraf_2 {} - обращение через точку(.)

    по тегу <p></p> - будут выбраны все теги р, на которые не ссылаются из ксс по классу или айди
    p {} - обращение через названия тега

    по * - универсальный селектор, обращается сразу ко всем элементам на странице
    * {font-size: 30px;} - применится ко всем тегам в которых есть текст.

    по аттрибуту <input type='text'> <input type='number'>
    input[type='text'] {}  - оюратится только к инпуту с аттрибутом текст

    по псевдо-классу - они применяются к специальному состоянию элемента
    p:first-child {font-weight: bold;} - жирный текст будет только у первого параграфа который найдет слектор на странице

    по псевдо-элементу - стиль применится только к части элемента
    p::first-letter {color:grey;} - применится к каждой первой букве каждого параграфа ***перекрывайт айди и классы


    +++ ПРИОРИТЕТНОСТЬ СЕЛЕКТОРОВ

    Если к одному елементу применить стили по айди и по классу то применятся стили того селектора приоритет которого выше.
    * !important - самый важный, применяется в первую очередь    .none { display: none !important;}
    * inline стили - которые прописываются в style в хтмл теге
    * id
    * class/pseudo-class/attribute
    * Tag
    * Browser default


    +++ ГРУППИРОВКА СЕЛЕКТОРОВ

    Видим что в нашме ксс файле много стилей дублируются. Что бы избежать нагромождения и дублирования кода можно их вынести в
    отдельный селектор, а в отдельных селекторах их удалим.
    header, aside, main, footer {
        text-align: center; 
        padding-top: 30px; 
    }


    +++ КОРОТКАЯ ЗАПИСЬ

    font, background, margin, padding - можно записывать сокращенно.
    Например если нужно сделать контур мы пропишем
    p {
        border-style: dashed;
        border-color: red;
        border-width: 5px;
        padding-top: 10px;
        padding-right: 20px;
        padding-bottom: 30px;
        padding-left: 40px;
    }
    сокращенно будет выглядеть так 
    p {
        border: 5px dashed red; - порядок любой (border: dashed  red 5px; - работает также)
        padding: 10px 20px 30px 40px; - порядок важен всегда начинается с top и идет по часовой стрелке
    }


    +++ НАСЛЕДОВАНИЕ - наследование стилей(цвет и размер текста, и т.п.) дочерними элементами от родительских элементов

    При разметке
    <div>
        Text in div
        <p>Some text</p> - этот параграф является дочерним относительно дива, а див относительно него является - родительским
    </div>
    <p>Some text</p>

    На странице все три строки отображаются по дефолтному стилю, цвет текста и размер текста. Если же применить к диву стили
    div {
        color: red;
        font-size: 30px;
    }
    то цвет и размер первого параграфа будут такие же как и у текста - Text in div, потому что он в середине родительского
    Но не все стили могут наследоваться, например обводка применится только к блоку див(обведется вокруг него), а к параграфу
    не применится
     div {
        borde: 2px solid red;
    }


    +++ ПОЗИЦИОНИРОВАНИЕ ХТМЛ БЛОКОВ

    position: static,
    position: relaive,
    position: absolute

    Позиционирование производится по системе координат x,y,z. При загрузке страницы происходит рендеринг элементов (заголовков, 
    рядков, блоков...). Рендеринг происходит в той последовательности в какой встречаются элементы на странице. Позиционировани
    упорядочивает процесс отображения всех элементов на странице. Позиционирование сооющает где должен располагаться элемент и 
    как влиять на окружающие его элем.

    В ксс свойство position может принимать 5 значений:

    *static - по умолчанию все элементы позиционируются с этим значением. Каждый элемент расположен с естественным порядком
              добаления его на страницу. Элементы блоков располагаются под элементами блоков, а линейные(строковые) - один за другим.

    *inherit - дочерний элемент наследует позищн от родительского.
    
    *fixed   - фиксированное. Всегда игнорирует родительские элементы и располагается относительно окна браузера.Во время просмотра
               страницы элемент не смещается. Применяется для создания вкладок, меню, заголовков,... элементов которые должны быть
               постоянно видны пользователю и оторые он не может проскролить.
               На практике
               button {position: fixed; top: 10px; right: 10px;} - кнопка вырывыется из структуры (стояла веред всеми картинками
                и прилягала к первой из них)будет в правом верхнем углу, перекрывать остальные элементы и не смещатся при скролле
                страницы, а остальные элементы займут место как будто кнопки нету в их родительском диве.
    
    *relative - относительное позиционирование. Эти элементы рсполагаются относительно своей позиции. Сдвиг производится относительно
                его стандартного положения. При сдвиге блока на его месте остается образ относительно которого все элементы
                располагаются и накладываются один на другой. Элементы с relative выходят из общего потока, но ведут себя так как 
                будто в нем находятся. 
                На практике два блока с картинками. При статике один находится под другим.
                .relative {position: relative; right: 100px; top: 100px; } - блок сместился в право на 100пкс и вниз на 100пкс,
                перекрыл собой второй блок, но второй блок остался на месте. как будто первый все еще занимает свое место в 
                структуре.
                ***Этот тип позиционирования не применяется к табличным элементам: столбцам, рядкам, ячейкам.
            
    *absolute - этот тип позиционирования вырывает блок из общего потока(структуры) документа. Точка отсчета - эти элементы 
                располагаются относительно ближайшего родительского элемента с позиционирование отличным от static(***НЕ static).
                Если такого родительского эл. нету - позиционирование производится относительно основного документа, тоесть
                элемента body. ***Для того что бы абсолютное поз. работало, нужно дочернему эл. прописать absolute, а родительскому
                relative.
                На практике
                Три картинки в диве. Диву присвоили .relative {position: relative; border: 2px red solid;}. Картинки при этом 
                располагаются подряд и их обворачивает контур от дива. Когда картинкам присвоим img{position:absolute;} - все три
                картинки сбиваются в левый верхний угол(начало) родительского дива и накладываются одна на одну, а див ведет себя так
                как будто в нем нету картинок и схлопывает контур в одну линию, потому что без содержимого его высота = 0.
                Если каждой картинке присвоить класс и прописать отступы, то они сместятся. .image1 {top: 10px; leaft: 10px;}
                .image2 {top: 100px; leaft: 100px;}  .image3 {top: 200px; leaft: 200px;} - в данном случае картинки будут располагаться
                наискось слева сверху - вправо вниз, сама нижняя будет перекрывать уголок средней, а средняя перекроет уголок верхней,
                а родительски див продолжит себя вести как будто он их игнорирует.
                Но если нам нужен обратный порядок перекрытия, нужно добавить z индекс - глубина(слой) чем больше значение, тем выше
                элемент на странице. .image1 {top: 10px; leaft: 10px; z-index: 30px;}
                .image2 {top: 100px; leaft: 100px; z-index: 20px;}  .image3 {top: 200px; leaft: 200px; z-index: 10px;} - теперь
                перекрытие начинается сверху, тоесть первая. верхняя картинка перекрывает чать второй средней, а она в свою очередь
                перекрывает часть третьей нижней картинки. Наибольшее значение з индекса - 9999. 
            

    +++ ОТНОСИТЕЛЬНЫЕ ВЕЛИЧИНЫ

    Нужно сделать 5 блоков которые будут идти один за другим и нужно что бы они изменялись при изменении размера окна.
    div {
    height: 200px;          - высота
    border: 2px solid black; - граница черная 2 пикселя 
    float: left;            - обтекание - построение в рядок
    width: 20%;             - ширина в относительных единицах
    box-sizing: border-box; - свойство что бы границы(рамки - border) включались в середину ширины
    }
    Так как ширина задана в % то при изменении окна в относительных единицах - 100% эта цифра не будет менятся, а в пикселях
    20% будут пересчитаваться исходя из размера в пикселях основного окна.


    +++ ОТСТУПЫ (box-model)

    С точки зрения ксс все хтмл элементы расматриваются как прямоугольники, поэтому в ккс есть понятние - box-model.
    box-model состоит из:
    *контента   - наполнение(текст, картинки,...)
    *padding    - внутришний отступ,
    *border     - граница(обводка, контур),
    *margin     - внешний отступ.


    +++ ВЕНДОРНЫЕ ПРЕФИКСЫ

    Когда новые возможности в ксс только вводятся они доступны в разных браузерах по вендорным префиксам. Например если добавить
    border-radius: 10px; скруглние краев рамки(в ВСкоде ничего не написало, наверное потому что это уже давно введено, а видео 2 года),
    на видео,вместе с ним добавились строки 
    -o-border-radius: 10px; 
    -moz-border-radius: 10px;  
    -ms-border-radius: 10px;
    -webkit-border-radius: 10px;
    border-radius: 10px;  - пишется последним в этих строк

    Они значат что это свойство корректно отобразится в -о- опере, -moz- мозилле фаерфокс,  -ms- макйкрософт ИЕ + эдж, 
    -webkit- для баузеров сафари и хром.


    +++ ПОРЯДОК ПРИСВОЕНИЯ СТИЛЕЙ

    *Positioning
    *Display & Box model
    *Color
    *Text
    *Other


    +++ CSS СТИЛИ
    text-decoration: underline; - нижнее подчеркивание
    text-transform: uppercase;  - Все буква заглавные
    text-align: center;         - выравнивание текста

    .list1 li {                 - заменяет стандартный черный кружок
          list-style-type: disc;    - стандартный
          list-style-type: circle;  - кружок пустой
          list-style-type: square;  - квадрат
      }


    +++ ПРАКТИКА. ПРИМЕНЕНИЕ КСС СТИЛЕЙ К СТРАНИЦЕ

    Перед началом нужно найти в интернете и подключить файл 
    normalize.css - подстраивает стили всех стандартных(дефолтные) элементов различных браузеров под единый стиль у всех браузерах.
    или 
    reset.css - обнуляет все стили (применяется если совсем не использовать стандартные(дефолтные) стили браузера ).

    Каждый браузер по умолчанию имеет разную разметку, отступы и свои стили, что бы это к стандартному(одинаковому отображению)
    нужно подключить файл normalize.css  который приведет стили во всех браузерах к одному виду.

    Так как мы планируем использовать стандартных(дефолтные) элементы браузера, то подключим нормалайз ксс.
    Вбиваем в поиске normalize css и по первой ссылке с гитхаба(https://github.com/necolas/normalize.css/) заходим в файл и копируем
    содержимое в свой файл который назовем  normalize.css, далее подключим его перед файлом написанных нами стилей main.css.

    Пишем стили. 
    Начинаем с хедера. 
    Добавим несколько классов для обращения к нему
    <header class="header">
            <div class="container">

    Разделим ксс файл комментариями на нескольк областей.
    /* GENERAL STYLES * / - тут будем писать код относящийся ко всему элементу
    /* HEADER * / - стили для хедера
    /* NAVIGATION * / - стили для навигации
    /* LOGIN FORM * / - стили для формы
    /* MAIN PART * /  - стили для основной части
    /* FOOTER * /       - стили для footera


    +++ Зададим стили для всего документа
    body {
        font-family: Arial, sans-serif; - стиль текста
        font-size: 100%;                - размер текста стандартный
    }
    Стиль для контейнера тоже поместим в дженерал(общие стили) потому что мы будем использовать его в разных блоках разметки
    .container {
        margin: 0 auto; - размещение по центру, внешние отступы всерху/снизу -0, по бокам авто - центрирует жлемент
        width: 960px;   - постоянная ширина блока
    }
    

    +++ Стили для хедера.
    .header {
        padding: 50px 0;                - внутришние отступы 50пкс сверху/снизу, 0 сбоков
        background-color: yellowgreen;  - бекграунд(фоновый) цвет
    }
    в хедере есть два заголовка, обращаемся к ним так
    .header h1, h2 {
        color: greenyellow;     - цвет текста
        text-align: center;     - размещение текста по центру блока
    }


    +++ Стили для навигации.
    Пропишем классы для тегов
    <nav class="page-navigation">
            <div class="container">
    <form class="login"  action="#">

    .page-navigation {
        background-color: #222;
        border-color: #101010;      - цвет границы ()
        min-height: 64px;           - минимальная высота (она может быть больше, но не меньше указанной) 
    }

    ***Система задания цвета:
    *по ключевому слову  red - браузер его парсит, понимает и отображает. (ограниченное количество цветов)
    *hex хекс(шестнадцатеричная система) код - #FFDD66 - два первые символа отвечают за красный, следующие 2 - зеленый, 
                                                            последние 2 - синий. Если символы повторяются то может быть
                                                            сокращенная запись #FFDD66 = #FD6
    *RGB(рджиби) - rgb(0, 255, 400) - числа означают красный, зеленый, синий цвета.
    *HSL (эйч эс эл) - hsl(160, 100%, 60%)  - тон, насыщенность, яркость ( hue, saturation, lightness)

    .page-navigation li {
        float:left;         - обтекание слева, выстраиваем в рядок(устарелый способ)
        width: 100px;       - ширина
    }
    .page-navigation a{
        display: block;     - делаем блочный элемент из ссылки, что бы он вел себя как блочный и растянулся на ширину width: 100px
                                а не принимал ширину контента
    color: #9d9d9d;
    line-height: 4em;       - высота рядка в условных единицах
    font-weight: bold;      - текст выделяется жирным
    text-align: center;     - размещение текста по центру
    }
    Сделаем чтобы стили изменялись при наведении на элемент меню
    .page-navigation li a:hover { - в навигации во всех тегах li при наведении курсора на гиперлинк a будут применятся эти стили
        color: yellowgreen;
        background-color: black;
    }
    Также в общие стили добавим стиль для списка что бы он не имел внешних и внутренних отступов
    ul {
        margin: 0;
        padding: 0;
    }
    ul li {     - убираем кружочки у элементов маркированного списка
        list-style-type: none;
    }
    Элементы разместились правильно, но у ссылок присутствует нижнее подчеркивание, уберем его
    a {
        text-decoration: none;
    }

    ***Работаем с формой
    /* LOGIN FORM * /
    .login {
        padding: 15px 0;    - вн. отступы 15 сверху/снизу, 0 - по бокам
        float: right;       - обтекание справа
    }

    .login input[type='text'], 
    .login input[type='password'] {     - выбираем два поля логин и пароль по аттрибуту
        padding: 5px;                   - вн. отступ по 5 пкс со всех сторон
        margin-right: 5px;              - внешний справа 5 пкс
        border: 1px solid transparent;  - граница цвет - прозрачный
        border-radius: 5px;             - радиус границы(скругление краев)
        outline: none;
    }
    Когда нажимаем на поле логина или пароля, у поля появляется обводка. уберем ее с помощью   outline: none;
    .login input[type='submit'] {
        padding: 5px 15px;              - вн. отступ
        border: 1px solid lightgray;
        border-radius: 5px;             - радиус границы(скругление краев)
    }
    Сделаем стили при наведении на кнопку
    .login input[type='submit']:hover {
        background-color: darkgray;
        color: white;
    }

    +++ Стили коллекций основной части /* MAIN PART * /
        Добавляем классы для первой коллекции и общий контейнер
        
        <main>
            <div class="container">

                <h2 class="collection-title">Image Collection <small>Visualize Quality</small></h2>
                <div class="collections">

                    <div class="collection-item-outer">
                        <div class="collection-item">
                            <img src="./img/cover.jpg" alt="cover" width="300">
                            <div class="collection-text">
                                <h2>List Item</h2>
                                <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. A, vitae.</p>
                                <button>Read more...</button>
                            </div>
                        </div>
                    </div>

                </div>

    .collections {
        overflow: auto;  - блок растягивается под контент, если контент выходит за рамки элемента то появляется полоса прокрутки
    }

    .collection-title {
        padding-bottom: 5px;
        border-bottom: 1px solid #777;  - нижнее подчеркивание под текстом
        font-size: 36px;
    }
    .collection-title small {
        color: gray;
        font-size: 70%;
    }
    .collection-item-outer {
        display: inline-block; - займет такой размер, каким размером будет его наполнение(инлайн элемент)
                                 и + будет вести себя как блочный элемент
        float: left;            
        padding-left: 5px;
        padding-right: 5px;
        width: 33.33%;          - так как элемента 3 задаем такой процентаж
        box-sizing: border-box; - что бы отступы входили в размер элемента
    }
    .collection-item {
    border: 1px solid #959595; - обводим рамкой модржимо карточки
    }

    .collection-item img {     - картинка будет занимать 100% своего блока
        width: 100%;
    }

    .collection-text {          - отступы для текста сверху 0
        padding: 0 20px 20px 20px;
    }

    .collection-text h2 {
        color: yellowgreen;
    }
    
    .collection-text p {

    }
    .collection-text button {
        padding: 10px;
        border: 1px solid transparent;
        border-radius: 5px;
        outline: none;
    }

    Видим что элементы разместились но они больше чем нам нужно, также есть ненужные отступы слевой и справо стороны, относительно
    верхнего подчеркивания.
    Удалим отступы
    .collections > div:first-child {  - ищем дочерний элемент див первого уровня вложенности первый элемент
        padding-left: 0;        -   убираем отступ слева(подвигаем блок влево), но теперь справа будет больше отступ
        padding-right: 5px;     - растягиваем блок, компенсируем появившееся пространство слева
    }
    Это будет этот див <div class="collections">
                            <div class="collection-item-outer">

    .collections > div:last-child { - такой же метод применяем для третьего(правого) последнего элемента
        padding-left: 5px;
        padding-right: 0px;
    }
    Теперь средний элемент выглядит меньше потому что элементы по бокам растянулись и от этого увеличили свою высоту.

    Текст слишком большой и текст отображается весь а это для на смного, сделаем фиксированное количество строк отображения,
    а остальные будут скрываться и появится скролл
    p {
        font-size: 13px;        - для всех р задаем шрифт меньше
        line-height: 1.3em;     - высота строки 1.3 от высоты шрифта
    }
    .collection-text p {
        max-height: 80px;  - макс высота, если текста немного то блок будет меньше, а если много то будет ограничиваться
        overflow: hidden;  - текст что выходит за границы будет скрываться
    }

    Если мы будем добавлять текст в заголовок, то он увеличится и потянет за собой увеличение блока - сломает верстку
    .collection-text h2 {
        color: yellowgreen;
        overflow: hidden;       - скрываем лишнее
        white-space: nowrap;    - не реагирует на пробелы (не переносит текст вниз а оставляет его как строку)
        text-overflow: ellipsis; - добавляет троеточие к видимой части
    }
    
    Добавим поведение ховера для кнопок в блоке
    .login input[type='submit']:hover,
    button:hover {
        background-color: darkgray;
        color: white;
    }

    У картинок в индексе уберем ширину потому что она уже задана в ксс.

    Переходим к видео блокам, присвоим аналогичным дивам такие же классы. На видео получилось что видеопроигрыватели больше блоков,
    а у меня получились меньше. Допишем для них селектор к селектору с шириной картинок
    .collection-item img,
    .collection-item video {
        width: 100%;
    }


    +++ Стили Футера
    Присвоим класс футер и контейнер для вложенного дива

    .footer {
        background-color: yellowgreen;
        color: white;
        padding: 20px 0;
        margin-top: 30px;
    }

    *** СТРАНИЦА ГОТОВА!!!

*/}


{/*  ==== FLEXBOX  ====

    FLEXBOX - однонаправленный метод разметки для упорядочивания элементов на странице в рядок или колонку. Был добавлен для решения
            проблемы с упорядочиванием элементов. Называется так потому что позволяет динамически распределять пространство между
            элементами неизвестного размера, flex - гибкий.
    
    При помощи него можно сверстать полный макет для сайта, но его основное назначение - стилизация отдельных контейнеров. А для
    построения общего макета больше подходит grid.

    Принцип работы флексбокса: есть контейнер и дочерние элементы он делит доступное пространство контейнера между дочерними
        элементами за определенными разработчиком правилами.

    Для того что бы контейнер стал флексбокс нужно в стилях контейнера прописать
    display: flex;  или display: inline-flex;

    ***ПРИМЕР
    Сделаем разметку, к дивам в контейнере присвоено 2 класса общий и с порядковым номером
      <body>
        <div class="container">
            <div class="container_item item-1">Flexbox Item 1</div>
            <div class="container_item item-2">Flexbox Item 2</div>
            <div class="container_item item-3">Flexbox Item 3</div>
        </div>
    </body>


    +++ СВОЙСТВА ДЛЯ КОНТЕЙНРА

    Пропишем стили
    .container {
        position: relative;
        border: 3px solid #333;
        background-color: #09f9dd;
    }

    .container_item {
        width: 150px;
        margin: 10px;
        background-color: #dfdfdf;
        border: 3px solid #333;
        text-align: center;
        color: #333;
    }

    .item-1 {
        min-height: 50px;
    }
    .item-2 {
        min-height: 100px;
    }
    .item-3 {
        min-height: 200px;
    }
    Теперь элементы находятся один над другим и имеют разную высоту. Нам нужно разместить элементы в рядок. Применяем флексбокс
    .container {
        position: relative;
        border: 3px solid #333;
        background-color: #09f9dd;
        display: flex;
    }
    Все элементы упорядочились в рядок и стали одной высоты. Ширина их 150 + 6 пкс(3 + 3 border) = 156 px. Но когда мы сужаем страницу
        элементы сужаются меньше заданной ширины width: 150px; для того что бы поместиться в вьюпорт, остановились на 139 пкс.
        Кргда страницу расширяем они восстанавливают заданную ширину и группируются в левой части экрана.

    Тоесть флексбокс опирается на наши рекомендации, но если невозможно их применить не испортив макета, таки образом пытается выйти 
        из положения.

    Также флексбокс позволяет стилизировать дочерние эл. контейнера из самого контейнера(например - размещать элементы в рядки и
        столбцы, выравнивать их, и указать как эл. могут увеличиваться или уменьшатся в этом контейнере) не трогая сами элементы.
        Правила флексбокс распространяются на контейнер и кложенные элементы первого уровня, на более глубокую вложенность не
        распространяется.

    Главная ось - вдоль которой выравниваются эл. При размещении в рядок она - горизонтальная, при размещ. 
        в колонку - вертикальная.

    Перекрестная ось - перпендикулярна главной оси(поперечная).

    Если хотим стилизовать эл. по *ГЛАВНОЙ оси используем  justify-content: ; свойство, оно определяет как браузер распределяется
        пространство между и вокруг эл. контента по главной оси флексконтейнера.
        
    По умолчанию  justify-content: flex-start; - можно не прописывать, при этом элементы размещаются один за одним и прижимаются
        к началу контейнера по главной оси в зависимости от ее направления.

    justify-content: center; - элементы один за одним в центре контейнера по главной оси.
    justify-content: flex-end; - элементы один за одним прижимаясь к концу контейнера по главной оси.
    justify-content: space-between; - первый эл прижат к началу контейнера, последний к концу, а между элементами создается 
        равное расстояние(равномерное распределение)
    justify-content: space-around; - между элементами создается равное расстояние(равномерное распределение) со всех сторон. 
        Например первый эл 35пкс он левого края - 35пкс в право к соседнему элементу, соседний элемент тоже дает по 35пкс в стороны,
        тогда получается что от краев будет по 30пкс, а между элементами 35+35=70 пкс
    justify-content: space-evenly; При этом способе расстояние между элементами уменьшилось стало 54пкс, а со сторон установилось
        как 50пкс


    Если хотим стилизовать эл. по *ПЕРЕКРЕСТНОЙ оси применяем align-items: ; это свойство выравнивает эл. по перпендикулярной оси.

    align-items: flex-start; - теперь заданная высота блоков вернулась. Эл. липнут к верхнему краю.
    align-items: center;     - теперь заданная высота блоков вернулась. Эл. центрируются.
    align-items: flex-end; - теперь заданная высота блоков вернулась. Эл. липнут к нижнему краю.
    align-items: stretch;   - эл. растягиваются и занимают все доступное пространство контейнера(по умолчанию)- в данном случае
                                все элементы стали по высоте равны самому высокому элементу.
    
    Если нужно применить это свойство к конкретному элменту в его селекторе пропишем align-self:
    .item-1 {
        align-self: center;
        min-height: 50px;
    }
    Теперь первый элемент уменьшился до своего размера и отцентрировался.

    
    align-content: center; - ничего не изменилось, потому что 1 ряд. Но если бы было больше рядов мы увидели бы. Это свойство 
        похоже на align-items но мужду рядками, задает варавнивание для каждого ряда эл. по перпендикулярной оси.

    Для наглядности работы элайнконтента добавим свойство флекс-врап со значением врап.
    flex-wrap: wrap; - определяет должны ли дочерние эл. переносится в мледующий рядок если им мало места или не должны. Тоесть
        эл. контейнера могут разбится на несколько рядков или размещатся в одном ряду.
        Увеличим ширину элементов и высоту контенера на 700, при этом 3й эл. перешел на следующий ряд и стал по центру относительно
        дополнительной (перпендикулярной оси У), а верхние два элемента растянулись и заняли от этой оси одинаковое расстояние
        Но по высоте они заняли место так чтобы от верхнего края эл. первого ряда к верхнему краю окна и от нижнего края эл. второго
        ряда до нижнего края окна расстояние было одинаковое 50 пкс. Но расстояние между рядами стало минимальным 6пкс

    .container {
        height: 700px;
        position: relative;
        border: 3px solid #333;
        background-color: #09f9dd;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
        align-items: center;
        align-content: center;
    }

    .container_item {
        width: 400px;
        margin: 10px;
        background-color: #dfdfdf;
        border: 3px solid #333;
        text-align: center;
        color: #333;
    }

    align-content: stretch; - при этом расстояние к сторонам верх/низ получилось по 25 пкс. а между рядками 25+25=50пкс
    align-content: flex-start; - все ряды сместились(по дополнительной оси) в верхнюю половину экрана 
    align-content: flex-end;    - все ряды сместились(по дополнительной оси) в нижнюю половину экрана 
    align-content:  space-between; - первый прилип к верхнему краю. второй в нижнему, между ними большое пространство
    align-content:  space-around; - расстояние к сторонам верх/низ получилось по 25 пкс. а между рядками 25+25=50пкс, ведут
                                    себя как при stretch


    +++ НАПРАВЛЕНИЕ ДОЧЕРНИХ ЭЛЕМЕНТОВ

    flex-direction - свойство указывает как будут располагаться эл. в контейнере по главной оси и направление нормальное или
                    обратное. Выбираем какая ось будет главная.
    
    flex-direction: row; - рядок *(свойство по умолчанию)
    flex-direction: row-reverse; - аналогичный рядок, но элементы идут в другом порядке и липнут теперь к противоположному краю.
    flex-direction: column; - колонка, при этом высота элементов возвращается и они снова стали разной высоты, контейнер по высоте
                                равен сумме всех их высот + отступы, и они все равно липнут к левой части контейнера
    flex-direction: column-reverse; - меняется только порядок эл., они все равно липнут к левой части контейнера.


    +++ СВОЙСТВА ДЛЯ ЭЛЕМЕНТА

    Свойства контейнера настраивают общее поведение дочерних эл. и общее их размещение. А те свойства которые
    применяем к дочернему элементу отдельно меняют дефолтное поведение одного из элементов, или задаем другой
    размер одному из них. 

    По умолчанию при уменьшении окна браузера элементы равномерно сужаются, но если мы хотим недопустить
    этого для первого элемента пропишем для него flex-shrink: 0;
    .item-1 {
        flex-shrink: 0;     - полностью предотвращает сужение элемента.
        min-height: 50px;
    }

    Элемент занимает все оставшееся пространство. *Но, так будет работать только если флексгоу указан для одного
    единственного элемента. Это свойство определяет коэфициент увеличения элемента по отношению к другим элементам
    в этом контейнере если есть свободное место. В контейнере потомки(дочерние эл) могут располагаться в любом
    направлении и менять свои размеры - увеличиться чтобы заполнить родительский элемент или уменьшится что бы не
    вылезти за его границы. Коэф. устанавливается цыфрами. 
    
    Если у контейнера 3 эл. и каждому присвоим флексгроув 1
    то все элменты займут равную площадь, тоесть будут одинаковыми по ширине(может и по всем размерам).
    
    Если для третьего указать флексгроув 2, то он будет расти в ширину в 2 раза больше остальных от 
    свободного места, так как у нас есть указанная ширина, то на вид этот элемент не будетименно в 2 раза больше
    двух других.
    .item-3 {
        flex-grow: 1;
        min-height: 200px;
    }

    Для того что бы при таком увеличении элемент игнорировал привязку к ширине можно прописать flex-basis: 0;
    (*для всех элементов?). Это свойство определяет начальную ширину эл которая будет являтся его начальными
    размерами, этот размер будет учитываться до того как свободное пространство контейнера начнет распределятся
    между его потомками. Тоесть контейнеры становятся равными 0, и все тело контейнера становится свободным
    местом, после этого происходит распределение.
    Флексбейсис может принимать любые значения как и width и height, а также слова auto и content. Отрицательные
    значения не работают.
    .item-3 {
        flex-basis: 0;
        flex-grow: 1;
        min-height: 200px;
    }

    +++ ПОРЯДОК(ОЧЕРЕДНОСТЬ) РАЗМЕЩЕЕНИЯ ЭЛЕМЕНТОВ

    Можно изменить порядок отображения элементов на странице не меняя при этом разметку благодаря свойству одер,
    его нужно прописать каждому элементу контейнера и указать какое место в новой очередности он будет занимать
    .item-1 {
        order: 2;
        flex-shrink: 0;
        flex-basis: 0;
        flex-grow: 1;
        min-height: 50px;
    }
    *** Это единственное свойство которое *НЕ рекомендуется использовать, потому что оно не влияет на скринридеры,
    которые читают элементы в той последовательности в которой они идут в ХТМЛ а не в заданой через флекс.
  
*/}

{/*  ====  Java Script  ====

    Java Script не имеет ничего общего с Java кроме того что часть названия java есть в названии JS и они оба языки 
    программирования.



    +++ ИСТОРИЯ СОЗДАНИЯ

    Брендон Айк (Brendan Eich) должен был сделать младшего брата Java, с легкой лексикой что бы непрограммисты могли быстрее
    освоить этот язык программирования.

    За 10 дней он сделал первую версию языка которая называласб  Mocha(Мока) - в честь одного из основателей Нетскейп(Мозилла),
    позже переименовали в LiveScript, у него было много недостатков но при этом он справлялся со своим основным заданием -
    работа с ХТМЛ без перезагрузки страницы. Еще через время его переименовали в JavaScript - для привлечения большего внимания
    к языку, из-за популярности JAVA. Это сработало, люди обратили внимание и начали пробовать и использовать JavaScript,
    а в 1995 году больше 20ти компаний заявили что хотят использовать JavaScript в своих проектах как объектный скриптовый
    язык с открытым стандартом. В том же году с подачи Нетскейп язык был стандартизирован ассоциацией ECMA(Europeam Computer
    Manufacturers Associatiom), стандарт назвали ECMAScript - по той причине что слово Java уже было зарезервировано и его
    нельзя было использовать.



    +++ ВОЗМОЖНОСТИ И ОГРАНИЧЕНИЯ

    JS говорит браузеру как должна вести себя ХТМЛ страница. Он полностью интегрирован с ХТМЛ и КСС. Он поддерживается всем
    браузерами и поумолчанию в них включен, поэтому JS имеет всю информацию про браузер в котором находится пользователь.

    JS в браузере подключается напрямую из ХТМЛ файла и сразу исполняется без препроцессов.

    Широкая область применения: веб приложения, серверные приложения, мобильные приложения, виджеты, браузерные ОС, прикладное
    програмное обеспечение, офисные программы и т.д.

    JS УМЕЕТ изменять страницу, задавать стили, текст, добавлять или удалять теги, добавлять эффекты, анимацию, реагировать на
    действия пользователя и на события, проверяет(валидует) данные которые вводит пользователь на клиентской стороне, при этом
    уменьшается нагрузка на сервер, обращаться к серверу и подгружать данные без перезагрузки страницы, работает с локальным
    хранилищем данных.

    JS НЕ УМЕЕТ закрывать окна и вкладки которые были открыты не с его помощью, не может защитить свой сорс код(код, текст и
    картинки со страницы можно скопировать), не может делать кроссдоменные запросы без специального разрешения, не имеет доступа
    к локальным файлам на вашем компьютере(исключение - кукис - небольшие файлы которые JS сам подгружает и может считать)



    +++  ПОДКЛЮЧЕНИЕ

    1) Писать код прямо в теге <script></script> в хтмл странице - используется для небольших проектов и скриптов, но при этом
        происходит загромождение кодом хтмл страницы что делает ее плохочитабельной, также при размещении в теге <head>
        останавливает загрузку страницы пока не выполнится сам скрипт.
            <head>
            <meta charset="UTF-8">
            <title>Prometheus webpage</title>
            <script>
                var a = 'Hello!';
                alert(a);
            </script>
        </head>

        <body>
            <div class="container">
                <div class="container_item item-1">Flexbox Item 1</div>
        
        Когда браузер будет рендерить(анализировать) страницу он дойдет до тега <script> и остановится на нем пока не отработает
        JS код, а потом продолжит с другими элементами. Тоесть разметка не не появится пока пользователь не повзаимодействует с
        alert.

    2) Подключение внешнего файла. Для этого сначала создадим данный файл script.js и подключим его
        <script src="./js/script_example.js"></script>

    Но если мы будем также подключать его в теге  head, то поведение не изменится, страница не будет загружатся пока не отработает
    скрипт. Поэтому рекомендуют что бы не замедлять загрузку страницы добавлять тег script со ссылкой на внешний файл добавлять
    в конец хтмл страницы перед закрывающим тегом бади </body>. Тогда браузер сначала отрендерит страницу, а потом дойдя до тега
    скрипт загрузит его.
    *НО если есть какой то код который должен сработать до загрузки страницы, тогда файл с этим кодом подключают в тег head.
    


    +++ ПРИНЦИПЫ РАБОТЫ, БАЗОВЫЕ ПОНЯТИЯ, ПЕРЕМЕННЫЕ

    Каждая строчка кода в JS - инструкция для браузера. Браузер читае и выполняет строчки последовательно. ; - означате что
        инструкция закончилась и далее идет следующая, если ее пропустить то браузер может слепить несколько инструкций
        в одну и мы получим не тот результат на который расчитывали.

    Все идентификаторы в JS регистрозависимые.

    Для сохранения информации в JS используют переменные, она состоит из имени и выделенной области памяти которая отвечает этой
        переменной. var+let - mutable, let+const - block scoped.
    
    Для создания(ОБЪЯВЛЕНИЯ) переменной используют ключевые слова let и const. Ранее использовалось также var. После let нужно
        задать переменной имя:
        let myMessage; 
        let mymessage; - это две разные переменные.
    После объявления переменной ей можно присвоить данные.
    Под эти данные выделяется память, и обратиться к ним можно с помошью имени переменной например вывести сообщение в консоль
        myMessage = 'Hello User!';
        console.log(myMessage); //'Hello User!'
        myMessage = 'Bye User!';                - данные в переменную можно перезаписать.
        console.log(myMessage); //'Bye User!'   - измененные данные потому что к этой строке данные в переменной изменились
    

    *** Имена переменных.
    Существует 3 ограничения: 
    1) имя может состоять только из букв, цифр, $(символа доллара) и _(нижнего подчеркивания).
    2) не могут начинатся с цифры
    3) нельза использовать зарезервированные слова
    Имя ппеременной должно давать максимально точную информацию про данные которые она хранит.

    Содержимое(сообщения) пишут только на английском, для того что бы любой программист мог понять что там написано.
    Короткие имена можно давать только тем переменным которые не несут смысловой нагрузки, например индексам
    Имена переменных из нескольких слов пишут camelCase
    Имя переменной должно четко отвечать ее содержимому


    ***CONST
    Если мы точно знаем что переменная не будет перезаписываться то можно объявлять ее через сonst. Попытка перезаписать константу
    выдаст ошибку в браузере.



    +++ ТИПЫ ДАННЫХ
    Присвоенные данные могут иметь разные типы. Также одной переменной можно присвоить разные типы данных(динамическая типизация
        это означает что типы существуют, но переменные к ним не привязываются)
        let number = 123;
        number = = "Some Text";


    *** Простые(примитивы) типы - 
        потому что им иожно присвоить только простые значения.

        1) число(целые и дробные)       
        let number = 123; let numberTwo = 123.45; 

        2) строка                       
        let str = "Some Text"; str = 'Some Text'; str = `Some Text`; - можно использовать все типы скобочек, главное что бы 
        открывающая и закрывающая были одного типа. Обратные скобочки позволяют встраивать в текст переменную.
        let name = 'Svitlana';
        console.log(`Hi ${name}`);

        3) логический(булевый) тип
        Имеет всего два значения true(истина/правда) и false(ложь/неправда)

        4) спец. значение null - означает что значения нету или оно неизвестно. let x = null;

        5) спец. значение undefined - значение неопределено( не присвоено) let x; - когда переменную объявили, но без значения.

        6) спец. уникальный идентификатор Symbol - используется для создания уникальных идентификаторов объектов. Символ создается
            вызовом функции Symbol  в которую(не обязательно) передается имя символа.

            let id = Symbol(); let id1 = Symbol('id'); let id2 = Symbol('id');
            console.log(id1 == id2); // false  - символы с одинаковыми именами будут разными

            Использование как уник. идентиф. объекта
            let user = {        создаем объект
                name: 'Jack',
                [id1]: 1,       - присваиваем идентификатор
                [id2]: 2
            };


        ***Эти два значения формально относят к типу числам, но по сути они ими не являются:
        1) infinity(бесконечность при делении на 0  - console.log(123/0);
        2) NaN(не число, если умножить(поделить?) на не число - console.log(123 * 'text'); но если передать в строку число
            тогда браузер попробует привести их к одному типу - console.log(1 * '3'); // выдаст число 3


    *** Объекты - 
        используются для коллекции данных и объявления более сложных сущностей. 

                        let user =          {name:          'Jack'};
        Состоит из названия объекта и пар свойство(ключ)    значение.

        Создадим объект
        let user = {
            name: 'Jack',
            age: 30,
            isAuth: true,
            jobs: {                 - в объект можно вложить другой объект
                first: 'Makler',
                second: 'Broker'
            },

        };
        Для обращения к объекту пишем свойство через точку или строку в квадратных скобках:
        console.log(user.name); // Jack
        console.log(user['name']); // Jack


    *** Массивы 
        используют что бы сохранять много переменных в одной последовательно.

        let arr = [1, 'two', false, {}, [], 6]; - может содержать разные типы данных.
        console.log(arr[0]); // 1 - Вывело первый элемент массива под индексом 0. Индекс первого элемента всегда 0.
        console.log(arr[1]); // two
        arr[1] = 2;                 - переприсвоили значение второго элемента(с индексом 1)
        console.log(arr[1]); // 2

        console.log(arr.length); // 6 - длинна массива, количество элементов.


        МЕТОДЫ МАССИВОВ

        arr.push(10, 11);     - добавляет элементы в конец массива и возвращает новую длинну массива 
        arr.unshift('01');    - добавляет элемент(ы) в начало массива в индекс 0, все остальные индексы сдвигаются и 
                                    возвращает новую длинну массива
        arr.pop();            - удаляет последний элемент(или элементы), возвращает их значение
        arr.shift();          - удаляет первый элемент массива ,  возвращает их значение


        let arr = [1, 2, 3, 4, 5];
        arr.join(); //'1,2,3,4,5'   - превращает все элементы массива в строку и возвращает ее
        arr.join(;); //'1;2;3;4;5'  - можно передавать разделитель которым будут разделены элементы


        arr.reverse();              - изменяет порядок значений в массиве на обратный *Изм. массив


        let arr = [2, 1, 3, 15, 6, 5, 4];
        let arr2 = ['Banana', 'Orange', 'Apple', 'Mango'];
        arr2.sort(); //['Apple', 'Banana', 'Mango', 'Orange'] - сортирует элементы в массиве в алфавитном порядке по первой букве
        arr.sort(); // [1, 15, 2, 3, 4, 5, 6]; - (если цифры то они тоже воспринимаются как строка и сравнение происходит по
                                                  первой цифре)           
        Чтобы числа сортировало по возрастанию(как числа), нужно добавить вспомогательную функцию, она принимает параметры - 
            а и b - это соседние элементы массива, при первой итеррации это будут 2 и 1, при второй 1 и 3, и т.д. Функция
            каждый раз возвращает разницу этих элементов а - b, если разница плюсовое число, элементы массива меняются местами,
            если равна 0 или отрицательная то элементы остаются на своих местах.
        arr.sort((a, b) => {
            return a - b
        });                 //// [1, 2, 3, 4, 5, 6, 15];


        let arr = [1, 2, 3, 4, 5];
        slice - возвращает указанный фрагмент массива. 
        arr.slice(0, 2); // [1, 2] - этом случае нужно вернуть 2 элемента начиная с индекса 0.


        splice - выполняет вставку или удаление элементов массива. 1й аргумент - в какой индекс вставлять элементы, 2й - сколько
                при этом нужно удалить элементов, далее элементы которые нужно вставить.
        let arr = [1, 2, 3, 4, 5];
        arr.splice(2, 0, 'Lemon', 'Kiwi'); // [1, 2, 'Lemon', 'Kiwi', 3, 4, 5]
        arr.splice(2, 1); // [1, 2, 'Kiwi', 3, 4, 5] - Удалить 1 элемент начиная из индекса 2.



    +++ АРИФМЕТИКА и ПРИСВОЕНИЕ


    *** Cтандартные операторы

    Для работы с переменными JS поддерживает все стандартные операторы +(прибавить), -(отнять), /(разделить), *(умножить).

    let a = 5,
        b = 6;
    
    console.log(a + b);  // 11
    console.log(a - b);  // -1
    console.log(a / b);  // 0.8333333333333334
    console.log(a * b);  // 30


    +(плюс) также поддерживает сложение строк(конкатенацию)
    let a = 'my',
        b = 'string';
    
    console.log(a + b);  // 'mystring'
    console.log(1 + 2);  // 3 -  при добавлении чисел они складываются
    console.log(1 + '2');  // '12' -  если хоть один элемент будет строка то произойдет конкатенация


    *** Инкремент (++), декремент(--)
        Увеличение(++) или уменьшение(--) на единицу, которое применяется только к переменным.

    let a = 2;
    a++;            // сокращение от a = a + 1;
    console.log(a); // 3

    let a = 2;
    a--;            // сокращение от a = a - 1;
    console.log(a); // 1


    *** Операторы сравнения
        Эти операторы возвращают логическое значение true/false.

    let a = 6,
        b = 5;
    
    console.log(a > b); // true - а больше б - правда
    console.log(a >= b); // true - а больше-равно б - правда
    console.log(a < b); // false  а меньше б - ложь
    console.log(a <= b); // false  а меньше-равно б - ложь
    
    console.log(5 == '5'); // true  число 5 равно строке '5' - (нестрогое сравнение сравнивает значение, если строка 
                                                                и число то пытается привести к одному типу. Не учитывает
                                                                тип сравниваемых элементов)
    console.log(5 === '5'); // false  5 строго-равно '5' - (строгое сравнение сравнивает также и типы, если типы не совпадают, 
                                                        дальнейшее сравнение не происходит)                                
    
    console.log(5 != '5'); // false  5  не равно '5'    
    console.log(5 !== '5'); // true  5  не строго-равно '5'  

    *** &&(и) и  ||(или)

    &&(и) - возвращает true если все условия правдивы(true).
    console.log(true && true); // true
    console.log(true && false); // false
    console.log(false && true); // false
    console.log(false && false); // false  

    Условия вычисляются слева на право, если на каком то этапе получает false, то проверка останавливается и возвращается false,
    Если все проверки окончились true, тогда оператор вернет результат сравнения последнего
    console.log(1 < 2 && 2 < 3 && 3 < 4); // true
    

    ||(или) - возвращает true если хоть одно условие правдиво(true)
    console.log(true || true); // true
    console.log(true || false); // true
    console.log(false || true); // true
    console.log(false || false); // false 



    +++ ВЗАИМОДЙСТВИЕ С ПОЛЬЗОВАТЕЛЕМ

    alert('Your message here'); - Останавливает выполнение скрипта пока пользователь не нажмет кнопку - ОК
                                    Окно которое выводится называется модальным - это значит что пока пользователь не 
                                    повзаимодействует с окном он не сможет взаимодействовать со страницей.

    let result = prompt(title, default); - Выводит модальное окно с текстом title и полем для ввода ответа, в которое можно
                                            прописать дефолтный текст default. У окна присутствуют кнопки ОК, Отменить.
                                            Введенный ответ будет присвоен переменной, если нажата кнопка Отменить - то 
                                            переменной присвоится null.
    let result = prompt('What is your name?', 'Jack');

    let result = confirm(question); - Модальное окно с вопросом. 2 кнопки ОК, Отменить. если нажата кнопка Отменить - то 
                                            переменной присвоится false, если ОК - тогда присвоится true.



                                    
    +++ УСЛОВИЯ

    





*/}