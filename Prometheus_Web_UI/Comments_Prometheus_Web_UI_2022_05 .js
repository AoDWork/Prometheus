{/*  ====  HTML  ====
    
    <html> - тег, состоит из имени тега и боковых скобок.

    <p>Tekst</p> - элемент, состоит из открывающего и закрывающего тегов и текста между ними.

    <a href='#' id='link'></a> - id - это аттрибут.

    head - вся информация про страницу, содержимое не отображается в браузере.

    body - главный контент страницы, содержимое отображается в браузере.



    +++  ЗАГОЛОВКИ И ФОРМАТИРОВАНИЕ ТЕКСТА

    <h1></h1>, h2, h3, h4, h5, h6 - заголовки - визуальное и логическое разделение информации по важности. Для обычного выделения
    текста заголовок не подходит (используем <b>/<strong>, <em>/<i>, <small>, <sup>, <sub>). Заголовки используются для логического
    выделения текста для поисковых систем.

    <p>Текст</p> - тег параграф служит обверткой для текста.

    <br> - служит для переноса далее следующего текста на новую строку.

    <b></b>, <strong></strong> - выделение жирным.

    <i></i>, <em></em> - выделение курсивом.

    <small></small> - уменьшение текста.

    <sup></sup> - делает текст надстрочным.

    <sub></sub> - делает текст подстрочным.

    <pre>                   -   показывает текст не убирая пробелы и переносы.
        текст
            с отступами
                и переносами
    </pre>

    <blockquote></blockquote> - выделение как цытаты.

    <mark></mark> - посдвечивает текст(как будто желтым маркером).



    +++ ОПРЕДЕЛЕНИЕ
    <dl> - definition list
        <dt> - definition title
        HTML
        </dt>
        <dd> - definition description
        Hyper Text Markup Language 
        </dd>
    </dl>

    <abbr title="HyperText Markup Language">HTML</abbr>  - показывает содержимое title при наведении на текст(расшифровка аббревиатур)



    +++ СПИСКИ

    Списки: маркированные - <ul></ul> и нумерованные <ol></ol>.  <li></li> - элемент списка.

    <ul>
        <li>Текст 1</li>
        <li>Текст 2</li>
        <li>Текст 3</li>
    </ul>

    <ol>
        <li>Номер 1</li>
        <li>Номер 2</li>
        <li>Номер 3</li>
    </ol>

    Вложенность

    <ol>
        <li>Номер 1</li>
        <li>Номер 2</li>
        <li>
            <ul>
                <li>Текст 1</li>
                <li>Текст 2</li>
            </ul>
        </li>
    </ol>



    +++ ГИПЕРССЫЛКИ

    <a href='google.com'>Google</a> - может переходить по внешней ссылке.
    <a href='google.com' target='_blank'>Google</a> - с аттрибутом бланк, откроет ссылку в новом окне.

    <a href='#parag'>Ссылка на параграф с айди parag</a> - переходит к элементу с заданным айди.



    +++ ВСТАВКА ИЗОБРАЖЕНИЙ

    <img src='./img/cat.jpg' alt='cat'> - вставит изображение которое находится в папке img с названием cat.jpg. Если картинка не 
    загрузится тогда на ее месте будет выводится текст из alt, также этот текст помогает поисковым система индексировать картинку.

    Также аттрибуты width и height - регулируют размер изображения. Обычно указывают только один параметр что бы изображение отобразилось
    пропорционально, также эти параметры резервируют место под картинку пока она не загрузилась, что бы не ломать верстку.

    <img src='./img/cat.jpg' alt='cat' height='300'>



    +++ ТАБЛИЦЫ

    <table>
        <caption>Основной заголовок</caption>
        <thead>
            <tr>
                <td>Заголовок столбца 1</td>
                <td>Заголовок столбца 2</td>
                <td>Заголовок столбца 3</td>
                <td>Заголовок столбца 4</td>
            </tr>
        </thead>

        <tbody>
            <tr>
                <td>Текст</td>
                <td>Текст</td>
                <td>Текст</td>
                <td rowspan='2'>Текст</td> - объединили 2 колонки вертикально
            </tr>
            <tr>
                <td>Текст</td>
                <td>Текст</td>
                <td>Текст</td>
                эта ячейка поглощена роуспаном
            </tr>
        </tbody>

        <tfoot>
            <tr>
                <td>Текст</td>
                <td>Текст</td>
                <td colspan='2'>Текст</td> - объединили 2 колонки горизонтально
                эта ячейка поглощена колспаном
            </tr>
        </tfoot>
    </table>



    +++ ФОРМЫ

    Тег форм обворачивает все инпуты. Нейм - имя формы, action - адресс скрипта который будет обрабатывать данные формы(куда отправляем),
    method - каким методом передается информация(POST - защищенный, GET - передает данные в адрессной строке).

    Вид инпута определяется значением в type.

    <form name='user_data' action='send.php' method='POST'> 
        <fieldset> - создает блок с обводкой вокруг элементов
        legend>Personal</legend> - видимое название блока с обводкой
        <label for='user_name'>Your name:</label>  - Текст перед полем. Для привязки(что бы по клику выбиралось нужное поле)
                                                                        используется аттрибут for по айди ***без хештега
        <input type='text' name='user_name' placeholder='Enter your name' id='user_name'>  - текстовое поле
        <br>
        <br>
        <label for='user_age'>Your age:</label>
        <input type='number' name='user_age' placeholder='Enter your age' id='user_age' required='true'> - числовое поле. 
                                            required - аттрибут указывает что нельзя отправлять форму без заполнения этого поля
        <br>
        <br>
        </fieldset>
        <label for='user_password'>Your password:</label>
        <input type='password' name='user_password' placeholder='Enter your password' id='user_password'> - поле для пароля, символы
        <br>                                                                                                закрываются звездочками.
        <br>
        <input type='radio' name='genre' value='male'>
        <input type='radio' name='genre' value='female'> - радио кнопки(круг), если name одинаковый то можно выбрать только один из них.                                                                                            
        <br>                                                                                                
        <br>
        <label for='remebmer'>Remebmer me:</label>
        <input type='checkbox' name='remebmer' id='remebmer'> - квадратик где можно ставить галочку(чекбокс).
        <br>                                                                                                
        <br>
        <select name='city'>   - выпадающий список
            <option value='Kyiv'>Kyiv</option>
            <option value='Lviv'>Lviv</option>
        </select>
        <br>                                                                                                
        <br>
        <label for='message'>Message:</label>
        <input type='textarea' name='message' id='message'>  - текстовое поле которое можно увеличивать.
        <br>                                                                                                
        <br>
        <input type='submit' value='Submitt'> - кнопка отправки формы, value - текст в середине кнопки.
    </form>



    +++ БЛОЧНЫЕ И СТРОЧНЫЕ ЭЛЕМЕНТЫ

    БЛОЧНЫЕ - которые содержат блок информации и начинаются с новой строки по умолчанию(Заголовки, параграфы, теблицы, формы)

    СТРОЧНЫЕ - элементы форматирования текста которые находстя в самом тексте (strong, sub, sup, гиперссылки, картинки)

    <div>текст</div> - блочный элемент обвертка для любого содержимого. Занимает всю ширину страницы.

    <spanТекст</span><spanТекст</span> - строчный элемент(второй текст начинается сразу за первым в той же строчке) - используется для
    выделения части текста что бы ему можно было присвоить стили отличительные от используемых на странице.



    +++ СЕМАНТИКА

    Семантика страницы нужна для правильного логического наполнения документа.
    Теги семантические 
    <header> - шапка сайта, 
    <footer>- подвал сайта, 
    <article> - статьи, формы, 
    <aside> - определяет блок сбоку для различный рубрик/архивов, 
    <section> - секция/раздел, может также быть с заголовком, 
    <main> - используется для основного документа, 
    <nav> - задает навигацию по сайту, если на странице несколько тегов со ссылками, то в нав помещают приоритетные,
    ...


    
    +++ Мультимедиа

    В аудио добавляют файлы с разным кодированием что бы разные браузеры могли его воспроизвести. Controls - нужен для того что бы
    появились элементы управления воспроизведением.
    <audio controls>
        <source src='sound.ogg' type='audio/ogg'>
        <source src='sound.mp3' type='audio/mpeg'>
        Your browser does not support audio
    </audio>

    Видео - если браузер очень старый тогда вместо видео будет отображен текст - Your browser does not support video
    <video width='320' height='240' controls>
        <source src='movie.ogg' type='movie/ogg'>
        <source src='movie.mp4' type='movie/mp4'>
        Your browser does not support video
    </video>

*/}


{/*  ====  Создаем страницу только на ХТМЛ.  ====

    Анализируем макет и выделяем 4 основные блока которые у нас будут - это Хедер, главное меню с формой логина <nav>, основная
    часть <main> и футер.

    добавляем комментарии перед секциями.

    Так как контент находится по центру экрана с отступами от крае то нужно весь этот контент обернуть в тег div для последующего
    редактирования в ксс.

    Создаем хеер и наполняем текстом h1 и h2 теги.
    Так как контент находится по центру экрана с отступами от крае то нужно весь этот контент обернуть в тег div для последующего
    редактирования в ксс.

    Для тега nav нужно сделать 2 элемента. Также обернем весь контент в div. 
    Главное меню состоит из списка(почему список хз) из трех элементов, сделаем как маркированный список и также в каждом элементе
    должна быть ссылка.
    В этой же строке должна быть форма авторизации поэтому ниже списка добавим коментарий и форму.

    Также обернем весь контент в div.
    В главной секции main  есть две секции (коллекции с тайтлом(h2) и 3 элементами в каждом из которых есть картинка, тайтл(h3), 
    контент/параграф и кнопка) для видео и для картинок, тоесть можно сверстать одину а для второй скопировать.
    Карточки коллеции тоже будут завернуты в div, еще 1 div для каждой карточки и еще 1 для параграфа??(скажет когда будем проходить ксс)

    После построения карточки копируем ее два раза, потом коллекцию копируем и заменяем тайтл на видео и вместо картинки вставляем видео
    <video controls>
        <source src='./video/movie.mp4' type='video/mp4'>
    </video>

    Весрстаем футер. Он состоит из контейнера и параграфа.

*/}


{/*  ==== CSS  ====

    CSS -  каскадная таблица стилей (cascading style sheets). (https://www3.cs.stonybrook.edu/~pramod.ganapathi/doc/CSE102/CSE102-CheatSheetCSSLong.pdf)


    Правила написания  H1 - селектор, color - свойство,  green - значение.

    h1:{
        color: green;
    }

    Пропишем в файле Ксс такой код, что бы он применился к тегу р нужно его подключить к файлу индекс
    p{
        color: red; 
        font-size: 30px;
    }



    +++ Варианты подключения ксс кода

    1) inline стиль - добавление ксс конструкции в тег хтмл при помощи аттрибута style=""

    2) Сохранение ксс в теге <style></style> которые находится в <head>

    3) Код ксс помещам в отдельны файл и добавляем путь к нему через тег <link> находится в <head>

    4) @import

    Рассмотрим на примере: Поделим страницу на блоки header, aside, main, footer и увидим каким способом удобнее всего добавлять
    стили

    Пропишем эти теги, майдбар и мейн завернем в еще 1 див.
    Пропишем инлайн стили background-color для каждого блока и введем текст что бы они начали отображаться. Прописываем ширину 900px
    и высоту 150px, в див элементе только ширину. Высоту мейн и эсайд прописываем в них и делаем по 200px. Теперь осталось разместить
    блоки в правильном порядке. 

    text-align: center; для всех тегов для установки текста по центру блока.
    padding-top: 30px;  для каждого блока сделает внутренний отступ для содержимого блока0.
    margin: 10px auto; - внешние отступы псверху/снизу 10пкс слева/справ - auto - отцентрирует блок.
    width: 300px; float: left; - для блока эсайн сделает его ширину 300 пикселей из 900 общих, а флоат лефт(обтекание слева)
                                    поставит блок в левую часть, так как у мейн нету ширины, он займет оставшееся место.
    
    Как можно увидеть при использовании такого количества инлайн стилей очень ухудшается читабельность кода, поэтому опробуем второй
    метод, вынесем теги в тег <style type='text/css'> в теге <head>. Видим что по верстке ничего не изменилось, и хоть перенос
    помог сделать код верстки читабельным, но все же загромоздил пространство в хтмл файле, поэтому перенесем весь код ксс
    в отдельный файл который находится в папке ксс  ./css/block.css и подключим их в теге head
    <link rel="stylesheet" href="./css/block.css">

    Подключить стили при помощи @import можно так - удаляем link, вместо него:
    <style type='text/css'>@import url("./css/block.css");</style>
    *** Недостаток такого подключения в том что при подключении нескольких ксс файлов при импорте браузер может не придерживаться
    очередности их подгрузки, а очередность важна потому что подгружаются: 1) дефолтные стили браузера, 2) стили из тега style
    прописаном в head - они перекрывают дефолтные стили, 3) самые главные - инлайн стили.



    +++ СЕЛЕКТОРЫ

    Позволяет обратится к одному или нескольким конкретным хтмл елементам.
    Селекторы бывают: id, class, тег, аттрибут, *, псевдо-элемент, псевдо-класс 

    Для id и class название мы выбираем самостоятельно, что бы не было путаницы в большом проекте рекомендуют следовать таким советам
    *можно использовать латинские буквы, цифры и спец символы
    *название селектора должно отвечать(быть логичным) месту его использования
    *свои правила имен, нужно выбрать единый стиль которым называть селекторы и использовать его во всем проекте

    Обращение к хтмл элементам из ксс:
    
    по id <p id='paragraf_1'></p> - айди дожен быть уникальным в рамках одной хтмл страницы
    #paragraf_1 {} - обращение через хештег(#)

    по class <p class='paragraf_2'></p> - один класс можно присвоить нескольким елементам
    .paragraf_2 {} - обращение через точку(.)

    по тегу <p></p> - будут выбраны все теги р, на которые не ссылаются из ксс по классу или айди
    p {} - обращение через названия тега

    по * - универсальный селектор, обращается сразу ко всем элементам на странице
    * {font-size: 30px;} - применится ко всем тегам в которых есть текст.

    по аттрибуту <input type='text'> <input type='number'>
    input[type='text'] {}  - оюратится только к инпуту с аттрибутом текст

    по псевдо-классу - они применяются к специальному состоянию элемента
    p:first-child {font-weight: bold;} - жирный текст будет только у первого параграфа который найдет слектор на странице

    по псевдо-элементу - стиль применится только к части элемента
    p::first-letter {color:grey;} - применится к каждой первой букве каждого параграфа ***перекрывайт айди и классы



    +++ ПРИОРИТЕТНОСТЬ СЕЛЕКТОРОВ

    Если к одному елементу применить стили по айди и по классу то применятся стили того селектора приоритет которого выше.
    * !important - самый важный, применяется в первую очередь    .none { display: none !important;}
    * inline стили - которые прописываются в style в хтмл теге
    * id
    * class/pseudo-class/attribute
    * Tag
    * Browser default



    +++ ГРУППИРОВКА СЕЛЕКТОРОВ

    Видим что в нашме ксс файле много стилей дублируются. Что бы избежать нагромождения и дублирования кода можно их вынести в
    отдельный селектор, а в отдельных селекторах их удалим.
    header, aside, main, footer {
        text-align: center; 
        padding-top: 30px; 
    }



    +++ КОРОТКАЯ ЗАПИСЬ

    font, background, margin, padding - можно записывать сокращенно.
    Например если нужно сделать контур мы пропишем
    p {
        border-style: dashed;
        border-color: red;
        border-width: 5px;
        padding-top: 10px;
        padding-right: 20px;
        padding-bottom: 30px;
        padding-left: 40px;
    }
    сокращенно будет выглядеть так 
    p {
        border: 5px dashed red; - порядок любой (border: dashed  red 5px; - работает также)
        padding: 10px 20px 30px 40px; - порядок важен всегда начинается с top и идет по часовой стрелке
    }



    +++ НАСЛЕДОВАНИЕ - наследование стилей(цвет и размер текста, и т.п.) дочерними элементами от родительских элементов

    При разметке
    <div>
        Text in div
        <p>Some text</p> - этот параграф является дочерним относительно дива, а див относительно него является - родительским
    </div>
    <p>Some text</p>

    На странице все три строки отображаются по дефолтному стилю, цвет текста и размер текста. Если же применить к диву стили
    div {
        color: red;
        font-size: 30px;
    }
    то цвет и размер первого параграфа будут такие же как и у текста - Text in div, потому что он в середине родительского
    Но не все стили могут наследоваться, например обводка применится только к блоку див(обведется вокруг него), а к параграфу
    не применится
     div {
        borde: 2px solid red;
    }



    +++ ПОЗИЦИОНИРОВАНИЕ ХТМЛ БЛОКОВ

    position: static,
    position: relaive,
    position: absolute

    Позиционирование производится по системе координат x,y,z. При загрузке страницы происходит рендеринг элементов (заголовков, 
    рядков, блоков...). Рендеринг происходит в той последовательности в какой встречаются элементы на странице. Позиционировани
    упорядочивает процесс отображения всех элементов на странице. Позиционирование сооющает где должен располагаться элемент и 
    как влиять на окружающие его элем.


    В ксс свойство position может принимать 5 значений:

    *static - по умолчанию все элементы позиционируются с этим значением. Каждый элемент расположен с естественным порядком
              добаления его на страницу. Элементы блоков располагаются под элементами блоков, а линейные(строковые) - один за другим.


    *inherit - дочерний элемент наследует позишн от родительского.
    

    *fixed   - фиксированное. Всегда игнорирует родительские элементы и располагается относительно окна браузера(вырывается из
               общего потока).Во время просмотра страницы элемент не смещается. Применяется для создания вкладок, меню, 
               заголовков, ... элементов которые должны бытьпостоянно видны пользователю и оторые он не может проскролить.
               
               На практике
               button {position: fixed; top: 10px; right: 10px;} - кнопка вырывыется из структуры (стояла веред всеми картинками
                и прилягала к первой из них)будет в правом верхнем углу, перекрывать остальные элементы и не смещатся при скролле
                страницы, а остальные элементы займут место как будто кнопки нету в их родительском диве.
    

    *relative - относительное позиционирование. Эти элементы располагаются относительно своей позиции. Сдвиг производится 
                его изначальной положения. При сдвиге блока на его месте остается образ относительно которого все элементы
                располагаются и накладываются один на другой. Элементы с relative выходят из общего потока, но ведут себя так как 
                будто в нем находятся. 
                
                На практике два блока с картинками. При статике один находится под другим.
                .relative {position: relative; right: 100px; top: 100px; } - блок сместился в право на 100пкс и вниз на 100пкс,
                перекрыл собой второй блок, но второй блок остался на месте. как будто первый все еще занимает свое место в 
                структуре.
                ***Этот тип позиционирования не применяется к табличным элементам: столбцам, рядкам, ячейкам.
            
    *absolute - этот тип позиционирования вырывает блок из общего потока(структуры) документа. Точка отсчета - эти элементы 
                располагаются относительно ближайшего родительского элемента с позиционирование отличным от static(***НЕ static).
                Если такого родительского эл. нету - позиционирование производится относительно основного документа, тоесть
                элемента body. ***Для того что бы абсолютное поз. работало, нужно дочернему эл. прописать absolute, а родительскому
                relative.
                
                На практике
                Три картинки в диве. Диву присвоили .relative {position: relative; border: 2px red solid;}. Картинки при этом 
                располагаются подряд и их обворачивает контур от дива. Когда картинкам присвоим img{position:absolute;} - все три
                картинки сбиваются в левый верхний угол(начало) родительского дива и накладываются одна на одну, а див ведет себя так
                как будто в нем нету картинок и схлопывает контур в одну линию, потому что без содержимого его высота = 0.
                Если каждой картинке присвоить класс и прописать отступы, то они сместятся. .image1 {top: 10px; leaft: 10px;}
                .image2 {top: 100px; leaft: 100px;}  .image3 {top: 200px; leaft: 200px;} - в данном случае картинки будут располагаться
                наискось слева сверху - вправо вниз, сама нижняя будет перекрывать уголок средней, а средняя перекроет уголок верхней,
                а родительски див продолжит себя вести как будто он их игнорирует.
                Но если нам нужен обратный порядок перекрытия, нужно добавить z индекс - глубина(слой) чем больше значение, тем выше
                элемент на странице. .image1 {top: 10px; leaft: 10px; z-index: 30px;}
                .image2 {top: 100px; leaft: 100px; z-index: 20px;}  .image3 {top: 200px; leaft: 200px; z-index: 10px;} - теперь
                перекрытие начинается сверху, тоесть первая. верхняя картинка перекрывает чать второй средней, а она в свою очередь
                перекрывает часть третьей нижней картинки. Наибольшее значение з индекса - 9999. 
            


    +++ ОТНОСИТЕЛЬНЫЕ ВЕЛИЧИНЫ

    Нужно сделать 5 блоков которые будут идти один за другим и нужно что бы они изменялись при изменении размера окна.
    div {
    height: 200px;          - высота
    border: 2px solid black; - граница черная 2 пикселя 
    float: left;            - обтекание - построение в рядок
    width: 20%;             - ширина в относительных единицах
    box-sizing: border-box; - свойство что бы границы(рамки - border) включались в середину ширины
    }
    Так как ширина задана в % то при изменении окна в относительных единицах - 100% эта цифра не будет менятся, а в пикселях
    20% будут пересчитаваться исходя из размера в пикселях основного окна.



    +++ ОТСТУПЫ (box-model)

    С точки зрения ксс все хтмл элементы расматриваются как прямоугольники, поэтому в ккс есть понятние - box-model.
    box-model состоит из:
    *контента   - наполнение(текст, картинки,...)
    *padding    - внутришний отступ,
    *border     - граница(обводка, контур),
    *margin     - внешний отступ.



    +++ ВЕНДОРНЫЕ ПРЕФИКСЫ

    Когда новые возможности в ксс только вводятся они доступны в разных браузерах по вендорным префиксам. Например если добавить
    border-radius: 10px; скруглние краев рамки(в ВСкоде ничего не написало, наверное потому что это уже давно введено, а видео 2 года),
    на видео,вместе с ним добавились строки 
    -o-border-radius: 10px; 
    -moz-border-radius: 10px;  
    -ms-border-radius: 10px;
    -webkit-border-radius: 10px;
    border-radius: 10px;  - пишется последним в этих строк

    Они значат что это свойство корректно отобразится в -о- опере, -moz- мозилле фаерфокс,  -ms- макйкрософт ИЕ + эдж, 
    -webkit- для баузеров сафари и хром.



    +++ ПОРЯДОК ПРИСВОЕНИЯ СТИЛЕЙ

    *Positioning
    *Display & Box model
    *Color
    *Text
    *Other



    +++ CSS СТИЛИ
    text-decoration: underline; - нижнее подчеркивание
    text-transform: uppercase;  - Все буква заглавные
    text-align: center;         - выравнивание текста

    .list1 li {                 - заменяет стандартный черный кружок
          list-style-type: disc;    - стандартный
          list-style-type: circle;  - кружок пустой
          list-style-type: square;  - квадрат
      }



    +++ ПРАКТИКА. ПРИМЕНЕНИЕ КСС СТИЛЕЙ К СТРАНИЦЕ

    Перед началом нужно найти в интернете и подключить файл 
    normalize.css - подстраивает стили всех стандартных(дефолтные) элементов различных браузеров под единый стиль у всех браузерах.
    или 
    reset.css - обнуляет все стили (применяется если совсем не использовать стандартные(дефолтные) стили браузера ).

    Каждый браузер по умолчанию имеет разную разметку, отступы и свои стили, что бы это к стандартному(одинаковому отображению)
    нужно подключить файл normalize.css  который приведет стили во всех браузерах к одному виду.

    Так как мы планируем использовать стандартных(дефолтные) элементы браузера, то подключим нормалайз ксс.
    Вбиваем в поиске normalize css и по первой ссылке с гитхаба(https://github.com/necolas/normalize.css/) заходим в файл и копируем
    содержимое в свой файл который назовем  normalize.css, далее подключим его перед файлом написанных нами стилей main.css.

    Пишем стили. 
    Начинаем с хедера. 
    Добавим несколько классов для обращения к нему
    <header class="header">
            <div class="container">

    Разделим ксс файл комментариями на нескольк областей.
    /* GENERAL STYLES * / - тут будем писать код относящийся ко всему элементу
    /* HEADER * / - стили для хедера
    /* NAVIGATION * / - стили для навигации
    /* LOGIN FORM * / - стили для формы
    /* MAIN PART * /  - стили для основной части
    /* FOOTER * /       - стили для footera



    *** Зададим стили для всего документа
    body {
        font-family: Arial, sans-serif; - стиль текста
        font-size: 100%;                - размер текста стандартный
    }
    Стиль для контейнера тоже поместим в дженерал(общие стили) потому что мы будем использовать его в разных блоках разметки
    .container {
        margin: 0 auto; - размещение по центру, внешние отступы всерху/снизу -0, по бокам авто - центрирует жлемент
        width: 960px;   - постоянная ширина блока
    }
    

    *** Стили для хедера.
    .header {
        padding: 50px 0;                - внутришние отступы 50пкс сверху/снизу, 0 сбоков
        background-color: yellowgreen;  - бекграунд(фоновый) цвет
    }
    в хедере есть два заголовка, обращаемся к ним так
    .header h1, h2 {
        color: greenyellow;     - цвет текста
        text-align: center;     - размещение текста по центру блока
    }


    *** Стили для навигации.
    Пропишем классы для тегов
    <nav class="page-navigation">
            <div class="container">
    <form class="login"  action="#">

    .page-navigation {
        background-color: #222;
        border-color: #101010;      - цвет границы ()
        min-height: 64px;           - минимальная высота (она может быть больше, но не меньше указанной) 
    }


    ***Система задания цвета:
    *по ключевому слову  red - браузер его парсит, понимает и отображает. (ограниченное количество цветов)
    *hex хекс(шестнадцатеричная система) код - #FFDD66 - два первые символа отвечают за красный, следующие 2 - зеленый, 
                                                            последние 2 - синий. Если символы повторяются то может быть
                                                            сокращенная запись #FFDD66 = #FD6
    *RGB(рджиби) - rgb(0, 255, 400) - числа означают красный, зеленый, синий цвета.
    *HSL (эйч эс эл) - hsl(160, 100%, 60%)  - тон, насыщенность, яркость ( hue, saturation, lightness)

    .page-navigation li {
        float:left;         - обтекание слева, выстраиваем в рядок(устарелый способ)
        width: 100px;       - ширина
    }
    .page-navigation a{
        display: block;     - делаем блочный элемент из ссылки, что бы он вел себя как блочный и растянулся на ширину width: 100px
                                а не принимал ширину контента
    color: #9d9d9d;
    line-height: 4em;       - высота рядка в условных единицах
    font-weight: bold;      - текст выделяется жирным
    text-align: center;     - размещение текста по центру
    }
    Сделаем чтобы стили изменялись при наведении на элемент меню
    .page-navigation li a:hover { - в навигации во всех тегах li при наведении курсора на гиперлинк a будут применятся эти стили
        color: yellowgreen;
        background-color: black;
    }
    Также в общие стили добавим стиль для списка что бы он не имел внешних и внутренних отступов
    ul {
        margin: 0;
        padding: 0;
    }
    ul li {     - убираем кружочки у элементов маркированного списка
        list-style-type: none;
    }
    Элементы разместились правильно, но у ссылок присутствует нижнее подчеркивание, уберем его
    a {
        text-decoration: none;
    }


    ***Работаем с формой
    /* LOGIN FORM * /
    .login {
        padding: 15px 0;    - вн. отступы 15 сверху/снизу, 0 - по бокам
        float: right;       - обтекание справа
    }

    .login input[type='text'], 
    .login input[type='password'] {     - выбираем два поля логин и пароль по аттрибуту
        padding: 5px;                   - вн. отступ по 5 пкс со всех сторон
        margin-right: 5px;              - внешний справа 5 пкс
        border: 1px solid transparent;  - граница цвет - прозрачный
        border-radius: 5px;             - радиус границы(скругление краев)
        outline: none;
    }
    Когда нажимаем на поле логина или пароля, у поля появляется обводка. уберем ее с помощью   outline: none;
    .login input[type='submit'] {
        padding: 5px 15px;              - вн. отступ
        border: 1px solid lightgray;
        border-radius: 5px;             - радиус границы(скругление краев)
    }
    Сделаем стили при наведении на кнопку
    .login input[type='submit']:hover {
        background-color: darkgray;
        color: white;
    }


    *** Стили коллекций основной части /* MAIN PART * /
        Добавляем классы для первой коллекции и общий контейнер
        
        <main>
            <div class="container">

                <h2 class="collection-title">Image Collection <small>Visualize Quality</small></h2>
                <div class="collections">

                    <div class="collection-item-outer">
                        <div class="collection-item">
                            <img src="./img/cover.jpg" alt="cover" width="300">
                            <div class="collection-text">
                                <h2>List Item</h2>
                                <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. A, vitae.</p>
                                <button>Read more...</button>
                            </div>
                        </div>
                    </div>

                </div>

    .collections {
        overflow: auto;  - блок растягивается под контент, если контент выходит за рамки элемента то появляется полоса прокрутки
    }

    .collection-title {
        padding-bottom: 5px;
        border-bottom: 1px solid #777;  - нижнее подчеркивание под текстом
        font-size: 36px;
    }
    .collection-title small {
        color: gray;
        font-size: 70%;
    }
    .collection-item-outer {
        display: inline-block; - займет такой размер, каким размером будет его наполнение(инлайн элемент)
                                 и + будет вести себя как блочный элемент
        float: left;            
        padding-left: 5px;
        padding-right: 5px;
        width: 33.33%;          - так как элемента 3 задаем такой процентаж
        box-sizing: border-box; - что бы отступы входили в размер элемента
    }
    .collection-item {
    border: 1px solid #959595; - обводим рамкой модржимо карточки
    }

    .collection-item img {     - картинка будет занимать 100% своего блока
        width: 100%;
    }

    .collection-text {          - отступы для текста сверху 0
        padding: 0 20px 20px 20px;
    }

    .collection-text h2 {
        color: yellowgreen;
    }
    
    .collection-text p {

    }
    .collection-text button {
        padding: 10px;
        border: 1px solid transparent;
        border-radius: 5px;
        outline: none;
    }

    Видим что элементы разместились но они больше чем нам нужно, также есть ненужные отступы слевой и справо стороны, относительно
    верхнего подчеркивания.
    Удалим отступы
    .collections > div:first-child {  - ищем дочерний элемент див первого уровня вложенности первый элемент
        padding-left: 0;        -   убираем отступ слева(подвигаем блок влево), но теперь справа будет больше отступ
        padding-right: 5px;     - растягиваем блок, компенсируем появившееся пространство слева
    }
    Это будет этот див <div class="collections">
                            <div class="collection-item-outer">

    .collections > div:last-child { - такой же метод применяем для третьего(правого) последнего элемента
        padding-left: 5px;
        padding-right: 0px;
    }
    Теперь средний элемент выглядит меньше потому что элементы по бокам растянулись и от этого увеличили свою высоту.

    Текст слишком большой и текст отображается весь а это для на смного, сделаем фиксированное количество строк отображения,
    а остальные будут скрываться и появится скролл
    p {
        font-size: 13px;        - для всех р задаем шрифт меньше
        line-height: 1.3em;     - высота строки 1.3 от высоты шрифта
    }
    .collection-text p {
        max-height: 80px;  - макс высота, если текста немного то блок будет меньше, а если много то будет ограничиваться
        overflow: hidden;  - текст что выходит за границы будет скрываться
    }

    Если мы будем добавлять текст в заголовок, то он увеличится и потянет за собой увеличение блока - сломает верстку
    .collection-text h2 {
        color: yellowgreen;
        overflow: hidden;       - скрываем лишнее
        white-space: nowrap;    - не реагирует на пробелы (не переносит текст вниз а оставляет его как строку)
        text-overflow: ellipsis; - добавляет троеточие к видимой части
    }
    
    Добавим поведение ховера для кнопок в блоке
    .login input[type='submit']:hover,
    button:hover {
        background-color: darkgray;
        color: white;
    }

    У картинок в индексе уберем ширину потому что она уже задана в ксс.

    Переходим к видео блокам, присвоим аналогичным дивам такие же классы. На видео получилось что видеопроигрыватели больше блоков,
    а у меня получились меньше. Допишем для них селектор к селектору с шириной картинок
    .collection-item img,
    .collection-item video {
        width: 100%;
    }


    *** Стили Футера
    Присвоим класс футер и контейнер для вложенного дива

    .footer {
        background-color: yellowgreen;
        color: white;
        padding: 20px 0;
        margin-top: 30px;
    }


    *** СТРАНИЦА ГОТОВА!!!


    *** Полезная инфа по КСС. Почти все свойстваи стили https://www3.cs.stonybrook.edu/~pramod.ganapathi/doc/CSE102/CSE102-CheatSheetCSSLong.pdf

*/}


{/*  ==== FLEXBOX  ====

    FLEXBOX - однонаправленный метод разметки для упорядочивания элементов на странице в рядок или колонку. Был добавлен для решения
            проблемы с упорядочиванием элементов. Называется так потому что позволяет динамически распределять пространство между
            элементами неизвестного размера, flex - гибкий.
    
    При помощи него можно сверстать полный макет для сайта, но его основное назначение - стилизация отдельных контейнеров. А для
    построения общего макета больше подходит grid.

    Принцип работы флексбокса: есть контейнер и дочерние элементы он делит доступное пространство контейнера между дочерними
        элементами за определенными разработчиком правилами.

    Для того что бы контейнер стал флексбокс нужно в стилях контейнера прописать
    display: flex;  или display: inline-flex;

    ***ПРИМЕР
    Сделаем разметку, к дивам в контейнере присвоено 2 класса общий и с порядковым номером
      <body>
        <div class="container">
            <div class="container_item item-1">Flexbox Item 1</div>
            <div class="container_item item-2">Flexbox Item 2</div>
            <div class="container_item item-3">Flexbox Item 3</div>
        </div>
    </body>



    +++ СВОЙСТВА ДЛЯ КОНТЕЙНРА

    Пропишем стили
    .container {
        position: relative;
        border: 3px solid #333;
        background-color: #09f9dd;
    }

    .container_item {
        width: 150px;
        margin: 10px;
        background-color: #dfdfdf;
        border: 3px solid #333;
        text-align: center;
        color: #333;
    }

    .item-1 {
        min-height: 50px;
    }
    .item-2 {
        min-height: 100px;
    }
    .item-3 {
        min-height: 200px;
    }
    Теперь элементы находятся один над другим и имеют разную высоту. Нам нужно разместить элементы в рядок. Применяем флексбокс
    .container {
        position: relative;
        border: 3px solid #333;
        background-color: #09f9dd;
        display: flex;
    }
    Все элементы упорядочились в рядок и стали одной высоты. Ширина их 150 + 6 пкс(3 + 3 border) = 156 px. Но когда мы сужаем страницу
        элементы сужаются меньше заданной ширины width: 150px; для того что бы поместиться в вьюпорт, остановились на 139 пкс.
        Кргда страницу расширяем они восстанавливают заданную ширину и группируются в левой части экрана.

    Тоесть флексбокс опирается на наши рекомендации, но если невозможно их применить не испортив макета, таки образом пытается выйти 
        из положения.

    Также флексбокс позволяет стилизировать дочерние эл. контейнера из самого контейнера(например - размещать элементы в рядки и
        столбцы, выравнивать их, и указать как эл. могут увеличиваться или уменьшатся в этом контейнере) не трогая сами элементы.
        Правила флексбокс распространяются на контейнер и кложенные элементы первого уровня, на более глубокую вложенность не
        распространяется.

    Главная ось - вдоль которой выравниваются эл. При размещении в рядок она - горизонтальная, при размещ. 
        в колонку - вертикальная.

    Перекрестная ось - перпендикулярна главной оси(поперечная).

    Если хотим стилизовать эл. по *ГЛАВНОЙ оси используем  justify-content: ; свойство, оно определяет как браузер распределяется
        пространство между и вокруг эл. контента по главной оси флексконтейнера.
        
    По умолчанию  justify-content: flex-start; - можно не прописывать, при этом элементы размещаются один за одним и прижимаются
        к началу контейнера по главной оси в зависимости от ее направления.

    justify-content: center; - элементы один за одним в центре контейнера по главной оси.
    justify-content: flex-end; - элементы один за одним прижимаясь к концу контейнера по главной оси.
    justify-content: space-between; - первый эл прижат к началу контейнера, последний к концу, а между элементами создается 
        равное расстояние(равномерное распределение)
    justify-content: space-around; - между элементами создается равное расстояние(равномерное распределение) со всех сторон. 
        Например первый эл 35пкс он левого края - 35пкс в право к соседнему элементу, соседний элемент тоже дает по 35пкс в стороны,
        тогда получается что от краев будет по 30пкс, а между элементами 35+35=70 пкс
    justify-content: space-evenly; При этом способе расстояние между элементами уменьшилось стало 54пкс, а со сторон установилось
        как 50пкс


    Если хотим стилизовать эл. по *ПЕРЕКРЕСТНОЙ оси применяем align-items: ; это свойство выравнивает эл. по перпендикулярной оси.

    align-items: flex-start; - теперь заданная высота блоков вернулась. Эл. липнут к верхнему краю.
    align-items: center;     - теперь заданная высота блоков вернулась. Эл. центрируются.
    align-items: flex-end; - теперь заданная высота блоков вернулась. Эл. липнут к нижнему краю.
    align-items: stretch;   - эл. растягиваются и занимают все доступное пространство контейнера(по умолчанию)- в данном случае
                                все элементы стали по высоте равны самому высокому элементу.
    
    Если нужно применить это свойство к конкретному элменту в его селекторе пропишем align-self:
    .item-1 {
        align-self: center;
        min-height: 50px;
    }
    Теперь первый элемент уменьшился до своего размера и отцентрировался.

    
    align-content: center; - ничего не изменилось, потому что 1 ряд. Но если бы было больше рядов мы увидели бы. Это свойство 
        похоже на align-items но мужду рядками, задает варавнивание для каждого ряда эл. по перпендикулярной оси.

    Для наглядности работы элайнконтента добавим свойство флекс-врап со значением врап.
    flex-wrap: wrap; - определяет должны ли дочерние эл. переносится в мледующий рядок если им мало места или не должны. Тоесть
        эл. контейнера могут разбится на несколько рядков или размещатся в одном ряду.
        Увеличим ширину элементов и высоту контенера на 700, при этом 3й эл. перешел на следующий ряд и стал по центру относительно
        дополнительной (перпендикулярной оси У), а верхние два элемента растянулись и заняли от этой оси одинаковое расстояние
        Но по высоте они заняли место так чтобы от верхнего края эл. первого ряда к верхнему краю окна и от нижнего края эл. второго
        ряда до нижнего края окна расстояние было одинаковое 50 пкс. Но расстояние между рядами стало минимальным 6пкс

    .container {
        height: 700px;
        position: relative;
        border: 3px solid #333;
        background-color: #09f9dd;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
        align-items: center;
        align-content: center;
    }

    .container_item {
        width: 400px;
        margin: 10px;
        background-color: #dfdfdf;
        border: 3px solid #333;
        text-align: center;
        color: #333;
    }

    align-content: stretch; - при этом расстояние к сторонам верх/низ получилось по 25 пкс. а между рядками 25+25=50пкс
    align-content: flex-start; - все ряды сместились(по дополнительной оси) в верхнюю половину экрана 
    align-content: flex-end;    - все ряды сместились(по дополнительной оси) в нижнюю половину экрана 
    align-content:  space-between; - первый прилип к верхнему краю. второй в нижнему, между ними большое пространство
    align-content:  space-around; - расстояние к сторонам верх/низ получилось по 25 пкс. а между рядками 25+25=50пкс, ведут
                                    себя как при stretch



    +++ НАПРАВЛЕНИЕ ДОЧЕРНИХ ЭЛЕМЕНТОВ

    flex-direction - свойство указывает как будут располагаться эл. в контейнере по главной оси и направление нормальное или
                    обратное. Выбираем какая ось будет главная.
    
    flex-direction: row; - рядок *(свойство по умолчанию)
    flex-direction: row-reverse; - аналогичный рядок, но элементы идут в другом порядке и липнут теперь к противоположному краю.
    flex-direction: column; - колонка, при этом высота элементов возвращается и они снова стали разной высоты, контейнер по высоте
                                равен сумме всех их высот + отступы, и они все равно липнут к левой части контейнера
    flex-direction: column-reverse; - меняется только порядок эл., они все равно липнут к левой части контейнера.



    +++ СВОЙСТВА ДЛЯ ЭЛЕМЕНТА

    Свойства контейнера настраивают общее поведение дочерних эл. и общее их размещение. А те свойства которые
    применяем к дочернему элементу отдельно меняют дефолтное поведение одного из элементов, или задаем другой
    размер одному из них. 

    По умолчанию при уменьшении окна браузера элементы равномерно сужаются, но если мы хотим недопустить
    этого для первого элемента пропишем для него flex-shrink: 0;
    .item-1 {
        flex-shrink: 0;     - полностью предотвращает сужение элемента.
        min-height: 50px;
    }

    Элемент занимает все оставшееся пространство. *Но, так будет работать только если флексгоу указан для одного
    единственного элемента. Это свойство определяет коэфициент увеличения элемента по отношению к другим элементам
    в этом контейнере если есть свободное место. В контейнере потомки(дочерние эл) могут располагаться в любом
    направлении и менять свои размеры - увеличиться чтобы заполнить родительский элемент или уменьшится что бы не
    вылезти за его границы. Коэф. устанавливается цыфрами. 
    
    Если у контейнера 3 эл. и каждому присвоим флексгроув 1
    то все элменты займут равную площадь, тоесть будут одинаковыми по ширине(может и по всем размерам).
    
    Если для третьего указать флексгроув 2, то он будет расти в ширину в 2 раза больше остальных от 
    свободного места, так как у нас есть указанная ширина, то на вид этот элемент не будетименно в 2 раза больше
    двух других.
    .item-3 {
        flex-grow: 1;
        min-height: 200px;
    }

    Для того что бы при таком увеличении элемент игнорировал привязку к ширине можно прописать flex-basis: 0;
    (*для всех элементов?). Это свойство определяет начальную ширину эл которая будет являтся его начальными
    размерами, этот размер будет учитываться до того как свободное пространство контейнера начнет распределятся
    между его потомками. Тоесть контейнеры становятся равными 0, и все тело контейнера становится свободным
    местом, после этого происходит распределение.
    Флексбейсис может принимать любые значения как и width и height, а также слова auto и content. Отрицательные
    значения не работают.
    .item-3 {
        flex-basis: 0;
        flex-grow: 1;
        min-height: 200px;
    }



    +++ ПОРЯДОК(ОЧЕРЕДНОСТЬ) РАЗМЕЩЕЕНИЯ ЭЛЕМЕНТОВ

    Можно изменить порядок отображения элементов на странице не меняя при этом разметку благодаря свойству одер,
    его нужно прописать каждому элементу контейнера и указать какое место в новой очередности он будет занимать
    .item-1 {
        order: 2;
        flex-shrink: 0;
        flex-basis: 0;
        flex-grow: 1;
        min-height: 50px;
    }
    *** Это единственное свойство которое *НЕ рекомендуется использовать, потому что оно не влияет на скринридеры,
    которые читают элементы в той последовательности в которой они идут в ХТМЛ а не в заданой через флекс.
  
*/}


{/*  ====  Java Script  ====

    Java Script не имеет ничего общего с Java кроме того что часть названия java есть в названии JS и они оба языки 
    программирования.



    +++ ИСТОРИЯ СОЗДАНИЯ

    Брендон Айк (Brendan Eich) должен был сделать младшего брата Java, с легкой лексикой что бы непрограммисты могли быстрее
    освоить этот язык программирования.

    За 10 дней он сделал первую версию языка которая называласб  Mocha(Мока) - в честь одного из основателей Нетскейп(Мозилла),
    позже переименовали в LiveScript, у него было много недостатков но при этом он справлялся со своим основным заданием -
    работа с ХТМЛ без перезагрузки страницы. Еще через время его переименовали в JavaScript - для привлечения большего внимания
    к языку, из-за популярности JAVA. Это сработало, люди обратили внимание и начали пробовать и использовать JavaScript,
    а в 1995 году больше 20ти компаний заявили что хотят использовать JavaScript в своих проектах как объектный скриптовый
    язык с открытым стандартом. В том же году с подачи Нетскейп язык был стандартизирован ассоциацией ECMA(Europeam Computer
    Manufacturers Associatiom), стандарт назвали ECMAScript - по той причине что слово Java уже было зарезервировано и его
    нельзя было использовать.



    +++ ВОЗМОЖНОСТИ И ОГРАНИЧЕНИЯ

    JS говорит браузеру как должна вести себя ХТМЛ страница. Он полностью интегрирован с ХТМЛ и КСС. Он поддерживается всем
    браузерами и поумолчанию в них включен, поэтому JS имеет всю информацию про браузер в котором находится пользователь.

    JS в браузере подключается напрямую из ХТМЛ файла и сразу исполняется без препроцессов.

    Широкая область применения: веб приложения, серверные приложения, мобильные приложения, виджеты, браузерные ОС, прикладное
    програмное обеспечение, офисные программы и т.д.

    JS УМЕЕТ изменять страницу, задавать стили, текст, добавлять или удалять теги, добавлять эффекты, анимацию, реагировать на
    действия пользователя и на события, проверяет(валидует) данные которые вводит пользователь на клиентской стороне, при этом
    уменьшается нагрузка на сервер, обращаться к серверу и подгружать данные без перезагрузки страницы, работает с локальным
    хранилищем данных.

    JS НЕ УМЕЕТ закрывать окна и вкладки которые были открыты не с его помощью, не может защитить свой сорс код(код, текст и
    картинки со страницы можно скопировать), не может делать кроссдоменные запросы без специального разрешения, не имеет доступа
    к локальным файлам на вашем компьютере(исключение - кукис - небольшие файлы которые JS сам подгружает и может считать)



    +++  ПОДКЛЮЧЕНИЕ

    1) Писать код прямо в теге <script></script> в хтмл странице - используется для небольших проектов и скриптов, но при этом
        происходит загромождение кодом хтмл страницы что делает ее плохочитабельной, также при размещении в теге <head>
        останавливает загрузку страницы пока не выполнится сам скрипт.
            <head>
            <meta charset="UTF-8">
            <title>Prometheus webpage</title>
            <script>
                var a = 'Hello!';
                alert(a);
            </script>
        </head>

        <body>
            <div class="container">
                <div class="container_item item-1">Flexbox Item 1</div>
        
        Когда браузер будет рендерить(анализировать) страницу он дойдет до тега <script> и остановится на нем пока не отработает
        JS код, а потом продолжит с другими элементами. Тоесть разметка не не появится пока пользователь не повзаимодействует с
        alert.

    2) Подключение внешнего файла. Для этого сначала создадим данный файл script.js и подключим его
        <script src="./js/script_example.js"></script>

    Но если мы будем также подключать его в теге  head, то поведение не изменится, страница не будет загружатся пока не отработает
    скрипт. Поэтому рекомендуют что бы не замедлять загрузку страницы добавлять тег script со ссылкой на внешний файл добавлять
    в конец хтмл страницы перед закрывающим тегом бади </body>. Тогда браузер сначала отрендерит страницу, а потом дойдя до тега
    скрипт загрузит его.
    *НО если есть какой то код который должен сработать до загрузки страницы, тогда файл с этим кодом подключают в тег head.
    


    +++ ПРИНЦИПЫ РАБОТЫ, БАЗОВЫЕ ПОНЯТИЯ, ПЕРЕМЕННЫЕ

    Каждая строчка кода в JS - инструкция для браузера. Браузер читае и выполняет строчки последовательно. ; - означате что
        инструкция закончилась и далее идет следующая, если ее пропустить то браузер может слепить несколько инструкций
        в одну и мы получим не тот результат на который расчитывали.

    Все идентификаторы в JS регистрозависимые.

    Для сохранения информации в JS используют переменные, она состоит из имени и выделенной области памяти которая отвечает этой
        переменной. var+let - mutable, let+const - block scoped.
    
    Для создания(ОБЪЯВЛЕНИЯ) переменной используют ключевые слова let и const. Ранее использовалось также var. После let нужно
        задать переменной имя:
        let myMessage; 
        let mymessage; - это две разные переменные.
    После объявления переменной ей можно присвоить данные.
    Под эти данные выделяется память, и обратиться к ним можно с помошью имени переменной например вывести сообщение в консоль
        myMessage = 'Hello User!';
        console.log(myMessage); //'Hello User!'
        myMessage = 'Bye User!';                - данные в переменную можно перезаписать.
        console.log(myMessage); //'Bye User!'   - измененные данные потому что к этой строке данные в переменной изменились
    

    *** Имена переменных.
    Существует 3 ограничения: 
    1) имя может состоять только из букв, цифр, $(символа доллара) и _(нижнего подчеркивания).
    2) не могут начинатся с цифры
    3) нельза использовать зарезервированные слова
    Имя ппеременной должно давать максимально точную информацию про данные которые она хранит.

    Содержимое(сообщения) пишут только на английском, для того что бы любой программист мог понять что там написано.
    Короткие имена можно давать только тем переменным которые не несут смысловой нагрузки, например индексам
    Имена переменных из нескольких слов пишут camelCase
    Имя переменной должно четко отвечать ее содержимому


    ***CONST
    Если мы точно знаем что переменная не будет перезаписываться то можно объявлять ее через сonst. Попытка перезаписать константу
    выдаст ошибку в браузере.



    +++ ТИПЫ ДАННЫХ
    Присвоенные данные могут иметь разные типы. Также одной переменной можно присвоить разные типы данных(динамическая типизация
        это означает что типы существуют, но переменные к ним не привязываются)
        let number = 123;
        number = = "Some Text";


    *** Простые(примитивы) типы - 
        потому что им иожно присвоить только простые значения.

        1) число(целые и дробные)       
        let number = 123; let numberTwo = 123.45; 

        2) строка                       
        let str = "Some Text"; str = 'Some Text'; str = `Some Text`; - можно использовать все типы скобочек, главное что бы 
        открывающая и закрывающая были одного типа. Обратные скобочки позволяют встраивать в текст переменную.
        let name = 'Svitlana';
        console.log(`Hi ${name}`);

        3) логический(булевый) тип
        Имеет всего два значения true(истина/правда) и false(ложь/неправда)

        4) спец. значение null - означает что значения нету или оно неизвестно. let x = null;

        5) спец. значение undefined - значение неопределено( не присвоено) let x; - когда переменную объявили, но без значения.

        6) спец. уникальный идентификатор Symbol - используется для создания уникальных идентификаторов объектов. Символ создается
            вызовом функции Symbol  в которую(не обязательно) передается имя символа.

            let id = Symbol(); let id1 = Symbol('id'); let id2 = Symbol('id');
            console.log(id1 == id2); // false  - символы с одинаковыми именами будут разными

            Использование как уник. идентиф. объекта
            let user = {        создаем объект
                name: 'Jack',
                [id1]: 1,       - присваиваем идентификатор
                [id2]: 2
            };


        ***Эти два значения формально относят к типу числам, но по сути они ими не являются:
        1) infinity(бесконечность при делении на 0  - console.log(123/0);
        2) NaN(не число, если умножить(поделить?) на не число - console.log(123 * 'text'); но если передать в строку число
            тогда браузер попробует привести их к одному типу - console.log(1 * '3'); // выдаст число 3


    *** Объекты - 
        используются для коллекции данных и объявления более сложных сущностей. 

                        let user =          {name:          'Jack'};
        Состоит из названия объекта и пар свойство(ключ)    значение.

        Создадим объект
        let user = {
            name: 'Jack',
            age: 30,
            isAuth: true,
            jobs: {                 - в объект можно вложить другой объект
                first: 'Makler',
                second: 'Broker'
            },

        };
        Для обращения к объекту пишем свойство через точку или строку в квадратных скобках:
        console.log(user.name); // Jack
        console.log(user['name']); // Jack


    *** Массивы 
        используют что бы сохранять много переменных в одной последовательно.

        let arr = [1, 'two', false, {}, [], 6]; - может содержать разные типы данных.
        console.log(arr[0]); // 1 - Вывело первый элемент массива под индексом 0. Индекс первого элемента всегда 0.
        console.log(arr[1]); // two
        arr[1] = 2;                 - переприсвоили значение второго элемента(с индексом 1)
        console.log(arr[1]); // 2

        console.log(arr.length); // 6 - длинна массива, количество элементов.


        МЕТОДЫ МАССИВОВ

        arr.push(10, 11);     - добавляет элементы в конец массива и возвращает новую длинну массива 
        arr.unshift('01');    - добавляет элемент(ы) в начало массива в индекс 0, все остальные индексы сдвигаются и 
                                    возвращает новую длинну массива
        arr.pop();            - удаляет последний элемент(или элементы), возвращает их значение
        arr.shift();          - удаляет первый элемент массива ,  возвращает их значение


        let arr = [1, 2, 3, 4, 5];
        arr.join(); //'1,2,3,4,5'   - превращает все элементы массива в строку и возвращает ее
        arr.join(;); //'1;2;3;4;5'  - можно передавать разделитель которым будут разделены элементы


        arr.reverse();              - изменяет порядок значений в массиве на обратный *Изм. массив


        let arr = [2, 1, 3, 15, 6, 5, 4];
        let arr2 = ['Banana', 'Orange', 'Apple', 'Mango'];
        arr2.sort(); //['Apple', 'Banana', 'Mango', 'Orange'] - сортирует элементы в массиве в алфавитном порядке по первой букве
        arr.sort(); // [1, 15, 2, 3, 4, 5, 6]; - (если цифры то они тоже воспринимаются как строка и сравнение происходит по
                                                  первой цифре)           
        Чтобы числа сортировало по возрастанию(как числа), нужно добавить вспомогательную функцию, она принимает параметры - 
            а и b - это соседние элементы массива, при первой итеррации это будут 2 и 1, при второй 1 и 3, и т.д. Функция
            каждый раз возвращает разницу этих элементов а - b, если разница плюсовое число, элементы массива меняются местами,
            если равна 0 или отрицательная то элементы остаются на своих местах.
        arr.sort((a, b) => {
            return a - b
        });                 //// [1, 2, 3, 4, 5, 6, 15];


        let arr = [1, 2, 3, 4, 5];
        slice - возвращает указанный фрагмент массива. 
        arr.slice(0, 2); // [1, 2] - этом случае нужно вернуть 2 элемента начиная с индекса 0.


        splice - выполняет вставку или удаление элементов массива. 1й аргумент - в какой индекс вставлять элементы, 2й - сколько
                при этом нужно удалить элементов, далее элементы которые нужно вставить.
        let arr = [1, 2, 3, 4, 5];
        arr.splice(2, 0, 'Lemon', 'Kiwi'); // [1, 2, 'Lemon', 'Kiwi', 3, 4, 5]
        arr.splice(2, 1); // [1, 2, 'Kiwi', 3, 4, 5] - Удалить 1 элемент начиная из индекса 2.



    +++ АРИФМЕТИКА и ПРИСВОЕНИЕ


    *** Cтандартные операторы

    Для работы с переменными JS поддерживает все стандартные операторы +(прибавить), -(отнять), /(разделить), *(умножить).

    let a = 5,
        b = 6;
    
    console.log(a + b);  // 11
    console.log(a - b);  // -1
    console.log(a / b);  // 0.8333333333333334
    console.log(a * b);  // 30


    +(плюс) также поддерживает сложение строк(конкатенацию)
    let a = 'my',
        b = 'string';
    
    console.log(a + b);  // 'mystring'
    console.log(1 + 2);  // 3 -  при добавлении чисел они складываются
    console.log(1 + '2');  // '12' -  если хоть один элемент будет строка то произойдет конкатенация


    *** Инкремент (++), декремент(--)
        Увеличение(++) или уменьшение(--) на единицу, которое применяется только к переменным.

    let a = 2;
    a++;            // сокращение от a = a + 1;
    console.log(a); // 3

    let a = 2;
    a--;            // сокращение от a = a - 1;
    console.log(a); // 1


    *** Операторы сравнения
        Эти операторы возвращают логическое значение true/false.

    let a = 6,
        b = 5;
    
    console.log(a > b); // true - а больше б - правда
    console.log(a >= b); // true - а больше-равно б - правда
    console.log(a < b); // false  а меньше б - ложь
    console.log(a <= b); // false  а меньше-равно б - ложь
    
    console.log(5 == '5'); // true  число 5 равно строке '5' - (нестрогое сравнение сравнивает значение, если строка 
                                                                и число то пытается привести к одному типу. Не учитывает
                                                                тип сравниваемых элементов)
    console.log(5 === '5'); // false  5 строго-равно '5' - (строгое сравнение сравнивает также и типы, если типы не совпадают, 
                                                        дальнейшее сравнение не происходит)                                
    
    console.log(5 != '5'); // false  5  не равно '5'    
    console.log(5 !== '5'); // true  5  не строго-равно '5'  


    *** &&(и) и  ||(или)

    &&(и) - возвращает true если все условия правдивы(true).
    console.log(true && true); // true
    console.log(true && false); // false
    console.log(false && true); // false
    console.log(false && false); // false  

    Условия вычисляются слева на право, если на каком то этапе получает false, то проверка останавливается и возвращается false,
    Если все проверки окончились true, тогда оператор вернет результат сравнения последнего
    console.log(1 < 2 && 2 < 3 && 3 < 4); // true
    

    ||(или) - возвращает true если хоть одно условие правдиво(true)
    console.log(true || true); // true
    console.log(true || false); // true
    console.log(false || true); // true
    console.log(false || false); // false 



    +++ ВЗАИМОДЙСТВИЕ С ПОЛЬЗОВАТЕЛЕМ

    alert('Your message here'); - Останавливает выполнение скрипта пока пользователь не нажмет кнопку - ОК
                                    Окно которое выводится называется модальным - это значит что пока пользователь не 
                                    повзаимодействует с окном он не сможет взаимодействовать со страницей.

    let result = prompt(title, default); - Выводит модальное окно с текстом title и полем для ввода ответа, в которое можно
                                            прописать дефолтный текст default. У окна присутствуют кнопки ОК, Отменить.
                                            Введенный ответ будет присвоен переменной, если нажата кнопка Отменить - то 
                                            переменной присвоится null.
    let result = prompt('What is your name?', 'Jack');

    let result = confirm(question); - Модальное окно с вопросом. 2 кнопки ОК, Отменить. если нажата кнопка Отменить - то 
                                            переменной присвоится false, если ОК - тогда присвоится true.



    +++ УСЛОВИЯ

    Что бы выполнялся разный код в зависимости от условия используют оператор условия if. В нем код выполняется если уловие 
    выполняется (верно/true), если не выполняется условие, можно использовать необязательный оператор else.
    

    *** if(condition){
        выполнится код при условии true
    } else {
        выполнится код при условии false
    }


    Рассмотрим на примере, спросим пользователь когда появился JS а ответ присвоим переменной

    let year = +prompt('when JS first appeared?', ''); - плюс перед ответом превратит строку из ответа пользователя в число.
    if (year === 1995){
        alert('You right!');
    } else {
        alert('That's not right!');
    }


    *** Можно задавать несколько условий с помощью еще одного не обязательного оператора else if
     if (year === 1995){
        alert('You right!');
    } else if(1990 < year && year < 2000){
        alert('You were close!');
    } else {
         alert('That's not right!');
    }


    *** Сокращенная запись(тернарный оператор)
    let age = +prompt('How old are u?', '');

    let prefix;

    if(age === 1){                          - обычная запись через if
        prefix = 'year';
    }else {
        prefix = 'years';
    }

    prefix = age === 1 ? 'year' : 'years';  - сокращенная запись (тернарный оператор) - уменьшаем количество строк записи, но если
                                                условий else if будет много то можно допустить ошибку.
    alert(`You are ${age} ${prefix} old`);


    *** Конструкция switch

    Для такой большой(сложной) конструкции можно сократить написание и улучшить читаемость
    let value  = +prompt('How old are u?', '');

    if(value === 3){                          
        alert('More...');
    } else if(value === 4){
        alert('You right!');
    } else if(value === 5){
        alert('Less...');
    } else {
        alert('I don't know...');
    }

    Оператор switch проверяет условие строгим сравнение и если находит соответствие выполняется код внутры case если не находит,
        тогда выполняется код по умолчанию(default); Если в конструкции убрать все стоп слова break, то даже после найденого 
        соответствия дальнейший код будет выполнен игнорируя условия. Если убрать одно слово из кейса который совпадет то код 
        будет выполняться до следующего слова break.
    switch(value) {
        case 3:
            alert('More...');
            break;
        case 4:
            alert('You right!');
            break;
        case 5:
            alert('Less...');
            break;
        default:
            alert('I don't know...');
    };



    +++ ЦИКЛЫ

    Для того что бы однотипный код выполнился несколько раз используют циклы. Циклов существует 4 основных типа:


    *** while - пока условие возвращает true выполнять код
    let i = 0;
    while(i < 3) {      - пока i будет меньше 3 будет выполнятся код console.log(i); и увеличиватся переменная i++; с 
                                каждой итерра цией(повтором) цикла.
        console.log(i);
        i++;
    }                   // 0, 1, 2


    *** do while - тоже что и while, но если условие не true, то цикл выполнится хотя бы 1 раз.
    do{
        console.log(i);
        i++;
    } while(i < 3);


    *** for - самый распространенный вид цикла, в условии мы 1м аргументом задаем переменную - аргумент отрабатывает 1 раз в начале
                циклы, 2м - условие проверяется перед каждым срабатыванием тела цикла, 3м действия с переменной выполняется после
                выполнения тела цикла, но перед следующей проверкой условия. 

    for (let a = 0; a < 3; a++){
        console.log(a);
    };

    Можно записать и так но точка с запятой должна сохранятся.
    let a = 0;
    for (; a < 3; a++){
        console.log(a);
    };


    *** Прерывание(выход из) цикла - можно выйти из цикла при помощи break.

    while(true){                                    - такой цикл будет бесконечным(потому что условие всегда true), 
        let value = prompt('Enter a number', '');
        if(value === null){                         - но можно дать пользователю возможность его остановить, нажав в окне Отмена
            break;                                          тогда переменной присвоится значение null и цикл остановится.
        }
        console.log(value);
    }


    *** Пропуск итерраций цикла (continue)
    for (let a = 0; a < 4; a++){
        if(a === 2){
            continue;
        }
        console.log(a);
    };                      // 0, 1, 3    - 2 пропустилось


    *** Перебор элементов массива
    let arr = [1, 2, 3, 4];

    for(let i = 0; i < arr.lenght; i++ ){
        console.log(arr[i]);
    };                      // 1, 2, 3, 4


    *** Перебор элементов объекта (for in) - такой метод подходит не только для массивов, а и для строк и вообще всех сущностей
                                                которые можно итеррировать
    let person = {
        name: 'Jack',
        surname: 'Smith',
        age: 30
    };

    for (let key in person) {
        console.log(person[key]);
    }                               // 'Jack'  'Smith'  30



    +++  ФУНКЦИИ 

    Существуют для того что бы не писать один и тот же повторяющийся код для однотипных действий которые нужно повторять много раз
        (приветствие пользователя на странцице, выполнять обсчеты(калькулятор)). Функция это блок кода прописанный(определенный) 
        один раз который можно вызывать многоразово.
    
    Главная цель функции избавиться от дублрования кода.

    Состоит из ключевого слова function, уникального имени функции(произвольно, но желательно что бы отражалось ее назначение), 
        по этому имени будет создана переменная по которой мы будем вызывать функцию, параметров в круглых собках передаваемых в
        функцию(необязательно), если параметров несколько - разделяемых запятой, тела функции(body) - исполняемый код.

    
    *** №1 Объявление(создание) функции (FUNCTION DECLARATION)
    
    function name (params, separeted, by, comas) {
        //body(тело функции)
    };

    Вызов(запуск работы) функции
    name (params, separeted, by, comas);


        * Пример, создадим ф-ю которая складывает 3 числа и результат суммы выводит в консоль.
    function count () {
        let num1 = 1;
        let num2 = 2;
        let num3 = 3;

        let result = num1 + num2 + num3;
        console.log(result)
    };
    count(); // 6  -  Вызов(запуск работы) функции

    Объявлять переменные можно не в теле функции, их можно передавать при помощи параметров.
    function count (num1, num2, num3) {
            let result = num1 + num2 + num3;
            console.log(result)
    };
    count(1, 2, 3); // 6  -  передаем значение параметров, равное по колличеству параметрам в объявленной функции. 

        * Если при вызове ф-и количество параметров будет меньше тогда ф-я выдаст результат NaN, а это нам не подходит.
    count(1); // NaN
    Тогда можно задать значения параметров по дефолту(умолчанию).
    function count (num1 = 1, num2 = 2, num3 = 3) { - если параметр не будет передан, ф-я использует дефолтное значение
    count(1); // 6

        *Особенностью этого метода создания ф-и (FUNCTION DECLARATION) является, то что ее можно вызвать в коде раньше чем она была 
        прописана.


    *** №2 создания ф-и (FUNCTION EXPRESSION) функциональное выражение. 

        Сначала объявляем переменную и ей присваиваем объект функции без названия. Вызов функции такой же. Но в этом случае так как
        и с объявлением переменных, такую функцию нельзя вызвать(использовать) раньше чем она объявлена(написана) в коде. используют
        такую запись ф-и если ее нужно объявить в зависимости от услови(??? нипанятна)
    
    let count = function (num1 = 1, num2 = 2, num3 = 3) {
            let result = num1 + num2 + num3;
            console.log(result)
    };
    count(1);


    *** №3 когда ф-я объявляется и сразу вызывается. 
    
        Обернем предыдущую ф-ю в дужки и добавим дужки для вызова. Такая ф-я не требует названия, потому что она испольняется
            (отрабатывает) сразу же при обновлении страницы в браузере.

    (function (num1 = 1, num2 = 2, num3 = 3) {
            let result = num1 + num2 + num3;
            console.log(result)
    })();

        *Присвоить имя нужно если мы вызываем эту ф-ю в середине нее же.

    (function count (num1 = 1, num2 = 2, num3 = 3) {
            let result = num1 + num2 + num3;
            count();
            console.log(result)
    })();


    *** return - ключевое слово которое останавливает(прерывает) выполнение функции и возвращает ее результат.

    let sum = function(a, b) {  - эта ф-я ничего не возвращает. Ф-я запускается, отрабатывает, завершает работу и после этого все
        let c = a + b;              её локальные переменные а, б, с пропадают из памяти копмьютера и обратится к ним больше нельзя.
    };
    console.log(sum(1, 2)); // undefined

    Такие ф-и используют если они передают результат в какую то следующую ф-ю.
    let sum = function(a, b) {  
        let c = a + b;
        sum2(c);                - передаем результат в ф-ю сам2.             
    };

    Чтобы получить рез-т работы ф-ии нужно применить return
    let sum = function(a, b) {  
        return a + b;
    };
    console.log(sum(1, 2)); // 3

    Также return может просто завершить работу ф-и при условии что ф-я не получила всех параметров. При этом к строчке где переменной
        с присваивается сумма а и б даже не дойдет.
    let sum = function(a, b) {  
        if(!a || !b) {
            return;
        }
        let c = a + b;
    };


    *** №4 Стрелочные функции (ARROW FUNCTION)

    Перепишем такую функцию в стрелочную
    let sum = function(a, b) {  
        return a + b;
    };

    let sum = (a, b) =>  a + b;   - ***если тело ф-и пишем в той же строке что и ее имя - это заменяет return
                                         
    let sum = a  =>  a * 2;     // если параметр один то можно записать без круглых скобок
    
    let sum = ()  =>  console.log("Hi");     // если параметров нету указываем пустые скобочки
    sum(); // "Hi"


    *** №5 Конструктор.

    Ф-я создается при помощи ключевых слов new Function. Такая запись полезна когда нужно сконструировать ф-ю во время выполнения
        программы, например из данных с сервера или от пользователя. Недостатки такой записи - трудно читаемость и возможная дырка
        в программе если придут невалидные данные от пользователя.

    let f = new Function("x", "y", "return x + y");
    console.log(f(1, 2));


    *** Порядок выполнения ф-и

    Каждая ф-я имеет четкий порядок выполнения.

    function name (argument) {
        let a = 1;
        return a + argument;
    };
    name(argument);

    1) Инициализация. Интерпретатор создает пустой объект и заполняет его. инициализирует все переменные (а и argument).
    
    2) Выполнение. Переменным присваиваются значения и выполняются команды.

    3) Удаление объекта с переменными и очищение памяти.

    * Не стоит перегружать ф-и, одна ф-я - одно действие.



    +++ ОБЛАСТЬ ВИДИМОСТИ ПЕРЕМЕННЫХ

        Может быть локальной или глобальной.


    *** Локальные переменные - которые объявлены в середине ф-и через let, const или переданые параметры(msg). Эти переменные
        доступны самой ф-и и вложенным в неё ф-ям, существуют пока выполняется ф-я или блок кода, в зависимости от того где они
        были объявлены. 

    let showMessage(msg) {
        let message = "Hello";
        console.log(message);   - работает потому что консольлог и message находятся в одном блоке(в середине функции)
    }
    showMessage(); // "Hello";
    console.log(message); // ошибка - потому что после вызова и отработки ф-и все ее переменные удаляются и будут недоступными

        * Все что происходит в середине ф-и - это локальная область видимости.


    Если в ф-и есть блоки кода с  if else, switch, while, do while, for то объявленные в середине них переменные будут
        доступны только в пределах этого блока.

    function count() {
        for(let i = 0; i < 3; i++) {
            let j = i * 2;
            console.log(j);     // 0, 2, 4 - работает
        }
        console.log(j);         // ошибка - как и в примере выше
    }
    count();

    Но если объявление переменных переместить выше в ф-и то они будут доступны для всех ее блоков.
    function count() {
        let i;
        let j;
        for( i = 0; i < 3; i++) {
             j = i * 2;
            console.log(j);     // 0, 2, 4 - цикл
        }
        console.log(j);         // 4 - только последнее значение
    }
    count();
    

    *** var - устарелый способ объявления переменных. При объявлении таким способом доступ к переменным останется после
                отрабатывания ф-и, потому что область видимости для таких переменных будет вся функция, а не только блок в котором
                ее объявили.

    function count() {
        for(var i = 0; i < 3; i++) {
            var j = i * 2;
            console.log(j);     // 0, 2, 4 
        }
        console.log(j);         // 4 
    }
    count();

    Возможен такой вариант - можно объявлять переменную с таким же именем без ошибки и интерпретатор будет брать последнее значение,
        с let и const так не сработает, выдаст ошибку. Таким образом можно случайно переобъявить уже имеющуюся переменную и сломать
        код.
    var name = 'Jack';
    var name = 'Peter';
    console.log(name);  // 'Peter'


    *** Глобальная область видимости.

    Глобальная переменная - та которая объявляется в глобальной области видимости, тоесть вне какой либо ф-и(блока, фигурных скобок).
    
    let name = 'Peter'; - глобальная
    functiom showMessage() {
        let message = "My name is" + name;
        console.log(message);
    }
    showMessage();      // "My name is Peter" - тоесть была использована переменная вне функции. Так получилось потому что при
    console.log(name);  // "Peter"              выполнении ф-и интерпретатор не нашел переменную name в функции и начал искать 
                                                на уровень выше, тоесть в глобальной области видимости(для этого примера) и 
                                                найдя там переменную взял ее значение.

    Если объявить переменную с таким же именем в ф-и, то интерпретатор не будет искать ее за пределами ф-и, а возьмет значение
        локальной, потому что у локальной переменной приоритет выше.
    let name = 'Peter';
    functiom showMessage() {
        let name = 'Jack';
        let message = "My name is" + name;
        console.log(message);
    }
    showMessage();      // "My name is Jack"
    console.log(name);  // "Peter" - консольлог и далее обращается к глобальной переменной.

    Если в ф-и использовать переменную без ключевого слова то, это значение присвоится глобальной переменной перезаписва ее, * но
        это плохая практика и так делать не стоит.
    let name = 'Peter';
    functiom showMessage() {
        name = 'Jack';
        let message = "My name is" + name;
        console.log(message);
    }
    showMessage();      // "My name is Jack"
    console.log(name);  // "Jack" - перезаписанная глобальная переменная.

    Если объявить локальную переменную с таким же именем после кода, тогда выдаст ошибку о том что невозможно использовать 
        переменную до того как она была инициализирована( потому что ф-я видит у себя локальную переменную и пытается взять
        ее значение и не идет искать на уровень выше) - такое поведение называется hoisting(всплывание переменных)
    let name = 'Peter';
    functiom showMessage() {
        let message = "My name is" + name;
        let name = 'Jack';
        console.log(message);
    }
    showMessage();      // ошибка
    console.log(name);  // остановка программы


    *** Область видимости JS называют scope - это набор переменных, объектов и функций к которым есть доступ из конкретной части
            программы.
        Глобальная область (window) - определена для программы в целом, переменные объявленные в этом контексте живут на протяжении
            выполнения программы. Могут быть перезаписаны в любой момент и занимают память. Поэтому всегда стараются писать код так
            что бы их количество было минимум.
        Локальная - определена в границах ф-и или блока(фигурных скобок). Локальные переменные живут пока выполняется ф-я или блок. 
            В сереине блока локальная переменная имеет приорите выше чем глобальная. Каждая вложенная ф-я имеет свою область
            видимости. Переменные объявленные в ф-и доступны всем вложенным ф-ям, а те которые объявлены в середине вложенной
            ф-и не доступны родительской ф-и.
    


    +++ DOM (Document Object Model - Объектная модель документа)

    Когда страница полность загружена из сервера, браузер создает DOM. Его можно предстваить как дерево элементов. Браузер создает
        иерархическую структур документа сохраняя взаимосвязи между элементами и относя в отдельные узлы теги, аттрибуты. текст,
        комментарии. Элемента head и body - имеют каждый свою ветку, а взаимосвязи между вложенными элементами сохраняются. Таким
        образом JS имеет доступ к каждому элементу на странице следовательно полную власть над ХТМЛ документом и может совершать
        следующие действия: изменять хтмл элементы на странице, аттрибуты, ксс стили, удалять существующие хтмл элементы и аттрибуты,
        добавлять новые, реагировать на действия пользователя относительно хтмл элементов, создавать новые события, и т.д.


    *** Поиск элемента на странице
        Для модифицирования или удаления ХТМЛ элемента, сначала нужно к нему обратиться(найти на хтмл странице). Обращаться можно
        разными способами.

        По id
        Для того что бы UI изменения не засоряли область в редакторе обернем их в анонимную функцию которая сама себя вызывает, в
            ней объявим переменную и присвоим ей соответственный элемент(<p id="_id" )
        (function() {
            let id = document.getElementById("_id");  - получили ссылку на элемент

            id.style.fontSize = "30px";              - изменим размер текста
        })();

        Все стили которые в ксс пишутся через дефис(-) в JS пишутся кемэл кейсом fontSize

        По классу
        (function() {
            let classArr = document.getElementByClassName("_class");  - получили ссылки на все элементы с этим классом(массив)
            for (let i = 0; i < classArr.lenght, i++) {              - что бы работать с ними, нужно их проитерировать(перебрать)
                classArr[i].style.color = "red";                     - изменим цвет всех элем. с таким классом на красный
            }                                                            
        })();

        По тегу
        Похожим способом можно искать все элементы по тегу, в данном случае по тегу параграф р
        (function() {
            let tagArr = document.getElementByTagName("p");  - получили ссылки на все элементы с этим тегом(массив)
            for (let i = 0; i < tagArr.lenght, i++) {              - что бы работать с ними, нужно их проитерировать(перебрать)
                tagArr[i].style.color = "green";                   - изменим цвет всех элем. с таким тегом на зеленый
            }                                                            
        })();

        Если нужно найти на странице все элементы которые отвечают определенному ксс селектору(любому - айди, классу,типу, аттрибуту,
            значению аттрибута) можно исмользовать querySelectorAll
        (function() {
            let elements = document.querySelectorAll("input");  - получили ссылки на все элементы с этим тегом(массив)
            for (let i = 0; i < elements.lenght, i++) {              - что бы работать с ними, нужно их проитерировать(перебрать)
                elements[i].style.backgroundColor = "yellow";       - изменим цвет фона всех элем. с таким тегом на желтый
            }                                                            
        })();

        Если использовать querySelector по тегу, то он найдет только первый элемент и остановится.
        (function() {
            let element = document.querySelector("input");  - получили ссылку на первый элемент с этим тегом
            element.style.backgroundColor = "yellow";       - обращаемся на прямую без перебора, так как у нас не массив
        })();
    
    

    +++ DOM МЕТОДЫ

        С получением доступа к  конкретному хтмл элементу можно производить с ним действия: добавлять, удалять, клонировать, 
    изменять, получать значение. Это можно выполнять при помощи ХТМЛ ДОМ методов - действий которые можно совершать с ХТМЛ
    ДОМ элементами.

    Получаем доступ к элементу параграфа с _id и изменим его текст на Hello world! с помощью метода innerHTML
    (function() {
            let id = document.getElementById("_id");  
            id.innerHTML = "Hello world!";              
        })();

    Можно получать значение, например <input type='text' value='Hi' />
    Получаем доступ к элементу input методом querySelector через тег input с аттрибутом text, и что бы получить значение value,
    применим метод value. И для вывода его на экран присвоим это значение элементу параграфа с _id
    (function() {
            let id = document.getElementById("_id"); 
            let value = document.querySelector("input[type='text']").value;  
            id.innerHTML = value;   
            id.style.color = "red"; - к одному и тому же элементу можно применять  разные методы       
        })();

    Элементы можно создавать, добавлять в ДОМ и удалять из него. Имеется список
    <ul id="list">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        <li>Fourth</li>
    </ul> 
    Создается новый элемент методом document.createElement(tag); Так как мы будем создавать дочерний элемент к элементу ul 
        назовем его child. Для добавления а него текста используем document.createTextNode(text). Создали два независимых элемента
        тег и текст, что бы их совместить применяем метод appendChild. Теперь когда создан элемент <li>Fifth</li> нужно указать
        куда добавить его в ДОМ, для этого получим доступ к его будущему родительскому элементу, и теперь также добавляем элемент
        child к родительскому parent методом appendChild - он всегда добавляет элемент в конец списка(родительского элемента).
    (function() {
            let child = document.createElement("li"); - передаем название тега который будет создан
            let text = document.createTextNode("Fifth");
            child.appendChild(text);    text стал дочерним узлом элемента child, <li>Fifth</li>
            let parent = document.getElementById("list"); 
            parent.appendChild(child);
        })();
    
    Если необходимо добавить элемента не в конец родительского, а например вторым, тогда используем метод
        parentElem.insertBefore(newElem,nextSubling) - он указывает перед каким из дочерних элементов будет добавлен новый узел.
        Для этого нужно сначала собрать все подобные элементы на странице в переменной items. 
        И методом parent.insertBefore(child, items[1]); - добавляем новый элемент перед вторым элементом массива с индексом 1.
    (function() {
        let child = document.createElement("li"); - 
        let text = document.createTextNode("Fifth");
        child.appendChild(text);    
        let parent = document.getElementById("list"); 
        let items = document.getElementsByTagName("li"); - получаем массив всех эл. li
        parent.insertBefore(child, items[1]);
    })();

    Для удаления элемента используем parentElem.removeChild(elem);
    (function() {
        let parent = document.getElementById("list"); 
        let items = document.getElementsByTagName("li"); - получаем массив всех эл. li
        parent.removeChild(items[0]); - удаляем первый элемента массива
    })();

    Для замены элменета другим метод parenElem.replaceChild(newElem, elem); - удаляет указанный, а на его место ставит новый
    (function() {
        let child = document.createElement("li"); - 
        let text = document.createTextNode("Fifth");
        child.appendChild(text);    

        let parent = document.getElementById("list"); 
        let items = document.getElementsByTagName("li"); 

        paren.replaceChild(child, items[2]); - заменим 3 элемент массива(списка)
    })();



    +++ СОБЫТИЯ

    JS может реагировать на следующие события: пользователь кликает на элемент или кнопку, проводит курсором мыши над элементом, 
    ввел данные в input поле или отправил форму, набирает текст; загрузилась страница, картинка; изменяется размер окна браузера,
    и т.д.


    События в JS можно объявлять разными способами.
    Рассмотрим пример замены текста при клике на нем. <h1 id="title">Click on this text!</h1>
    

    *** №1 - объявим событие как аттрибут элемента, дописываем в хтмл верстке аттрибут onclick, а в нем команду которая будет изменять
        текст this.innerHTML = 'Ooops'. Ключевое слово this - означает контекст выполнения всей функции, тоесть оно обращается
        к конкретному элементу по которому мы кликнули(конкретного элемента в контексте котрого должен выполнятся код).
    
    <h1 id="title" onclick="this.innerHTML = 'Ooops'" >Click on this text!</h1>


    *** №2 - присваивать аттрибуту не всю команду, а только функцию которая будет выполнять команду. 

    тоесть в индексе пишем
    <h1 id="title" onclick="chengeText(this)" >Click on this text!</h1>

    а в JS пишем
    function chengeText(element) {
        element.innerHTML = 'Ooops';
    }

    Можно обойтись и без ключевого слова this(в хтмл файле?), и обратиться к элементу напрямую по айди. Такой вариант возможен, но
        если на странице много элементов на которые навешаны события которые вызывают одну и туже функцию, особенно если должно
        происходить изменение этого конкретного элемента, то лучше передавать контекст вызова, тоесть тот конкретный элемент где
        сработало событие, что бы не потревожить остальные элементы.
    function chengeText(element) {
        document.getElementById("title").innerHTML = 'Ooops';
    }


    *** №3 - не загромождать хтмл файл, а написать код в JS файле, находить по айди или другому селектору нужный элемент и уже тогда
        изменить ему текст.
     <h1 id="title">Click on this text!</h1>
    
     document.getElementById("title").onclick = function () {
         this.innerHTML = "Ooops";
     }


     Чаще всего в работе буду встречаться следующий события: 
        - onclick   - пользователь кликнул по элементу
        - onload    - когда загрузилась страница или какая то ее часть
        - onchange  - для чекбоксов, радибаттонов когда изменяется их состояние
        - onmouseover   - пользователь держит курсор над элементом
        - onmouseout    - пользователь убрал курсор с элементома
        - onmousedown, onmouseup    - это onclick разделенное на нажатие клавиши(удержание) и отпускание клавищи.
        - onkeypress, onkeydown, onkeyup    - нажатие клавиши на клавиатуре поделенное на 3 аналогично мыши
        - onfocus   - пользователь выбрал элемент или вводит в поле текст
        - onblur    - когда фокус с элемента снимается(клик по другому месту страницы(элементу))

     Пример mouseover, mouseout
     <h1 onmouseover="style.color='red'" onmouseout="style.color='green'">Mouse over this text</h1>

     Пример onfocus, onblur
     <input type="text" onfocus="myFunction(this)" />

    function myFunction(elem) {
        elem.style.backgroundColor = 'yellow' 
    }



    +++ ИНТЕРАКТИВНОСТЬ ДЛЯ СОЗДАННОЙ СТРАНИЦЫ

    Сделаем при клике на кнопку Read more что бы показывался весь текст который скрыт? а кнопка изменяла свой текст на Show less,
        и обратное действие при нажатии Show less текст свертывался и менялся текст на Read more.

    Создаем и подключаем файл со скриптами main.js по пути  <script src="./js/main.js"></script>
    
    В ксс файле нужно найти параграф .collectiom-text p{ и в нем изменить max-height на просто height, потому что max-height не
        позволяет изменять высоту блока.
    
    В индексе в кнопке прописываем событие onclick - и передаем в функцию контекст вызова this, тоесть конкретную кнопку в контексте
        которой вызывается ф-я, что бы при вызове ф-и она не срабатывала для всех кнопок.
    <button onclick="showText(this)">Read more...</button>
    
    Скопируем это событие в следующие две кнопки этой секции

    Описываем ф-ю в джава скрипт документе
    Создаем ф-ю, в ней мы первым делом проверяем высоту предыдущего элемент, так как кнопка идет как раз после параграфа,
        тоесть проверяем высоту предыдущего соседа относительно кнопки button при помощи метода previousElementSibling получаем
        его высоту clientHeight и сравниваем с 80 пикселями при свернутом состоянии. Если высота равна 80 пикселям, тогда
        разворачиваем блок на 100%, путес обращения опять же к этому элементу и задания через стили высоты в 100%

    function showText(el) {
    if(el.previousElementSibling.clientHeight === 80){
        el.previousElementSibling.style.height = "100%";
        el.innerHTML= "Show less";
    }

    Если высота не равна тогда выполняем обратные действия
    } else {
        el.previousElementSibling.style.height = "80px";
        el.innerHTML= "Read more...";
    }



    +++ ИНСТРУМЕНТЫ ВЕБ РАЗРАБОТЧИКА

    Часто программисты допускают ошибки которые потом нужно исправить. Они делятся на 
        - синтаксические - не присвоили значение переменной, забыли закрыть скобку. Про эти ошибки браузер нас сразу извещает 
                            сообщением в консоли с описанием ошибки и местом(строкой) где она произошла. При этом программа или
                            не запускается или перестает работать с места ошибки, пока мы не исправим их.

        - логические - такие ошибки найти труднее. Для их поиска используют дэбаггинг - пошаговый запуск программы по мере ее
                        выполнения для отслеживания правильности написания логики и правильности передаваемых данных.

    Проще всего дэбажить код прямо в браузере, у них всех есть похожие инструменты разработчика. Рассмотрим на примере GoogleChrome,
    Открыть инструменты разработчика можно нажав f12 или Crtl + Shift + I или нажав в правом верхнем углу 
        три точки(меню)-> другие инструменты-> инструменты разработчика.
    Откроется поле с 8ю закладками. Чаще всего используют:

    - Elements - помогает проинспектировать хтмл и ксс код страницы, тут егом можно изменить/удалить и изменения сразу отобразятся
                в браузере, но при обновлении страницы код загрузится из хтмл файла. Наведя на какой то элемент в коде его 
                подсветит на странице. Можно также кликнуть правой клавишей  на странице на элемента и выбрать - просмотреть код,
                тогда этот элемент выберется в вкладке Elements.

    - Console - выводил баги и ошибки. Также это место где можно комуницировать со страницей, можно объявлять переменные, обращаться
                к существующим переменным, вызывать существующие ф-и или объявлять новые.

    - Sources - вкладака используется для дэбаггинга. Тут можно видеть какие документы подключены, ставить брейкпоинты, на которых
                браузер будет останавливать выполнение кода и анализировать данные которые приходят. Например выбрав JS файл
                видим свой код.
                function showText(el) {
                    if(el.previousElementSibling.clientHeight === 80){
                        el.previousElementSibling.style.height = "100%";
                        el.innerHTML= "Show less";
                    } else {
                        el.previousElementSibling.style.height = "80px";
                        el.innerHTML= "Read more...";
                    }
                И кликнув слева от него на номере строки например 2, 4, 6, потом на странице нажимаем на кнопку Read more... и
                программа останавливается сначала на 2й строке(if), наведя курсор на el в showText(el) можно увидеть информацию
                про передаваемый объект. А если нужно увидеть какие данные пришли выделяем фрагмент строки
                el.previousElementSibling.clientHeight и правой кнопкой кликаем на нем выбрав add to watch и в окне справа
                раскрывается секция watch в которой видно какой элемент и какое значение пришло. 
                *Что бы продолжать работу программы далее нужно нажать кнопку справа над панелькой "Resume script execution F8",
                тогда выполнение кода продолжится до следующего брейкпоинта строка 4(innerHTML), нажимаем еще раз и программа
                проскакивает(не останавливается на строке 6(превая строка блока else)) потому что туда код не дошел, так как
                выполнилось первое условие блока if else.

    - Network - в реальном времени отображает ресурсы на которые посылает запрос браузер и ресурсы которые загрузились. В нашем 
                случае загрузилась картинка. Кроме этого можно оценить время загрузки этой картинки.

    - Timeline - показывает сколько времени нужно для загрузки ресурсов, выполнения скриптов, расчета стилей и рендеринга и
                    отрисовки страницы.

    - Resources - отображаются все стореджи(места хранения) на клиентской стороне.



    +++ МЕТОДЫ ДЕБАГГИНГА В КОДЕ


    *** №1 console.log(el) - при срабатывании в консоль выводится элемент который передан в ф-ю не останавливая работу программы.

    function showText(el) {
        console.log(el)
        if(el.previousElementSibling.clientHeight === 80){
            el.previousElementSibling.style.height = "100%";
            el.innerHTML= "Show less";
        } else {
            el.previousElementSibling.style.height = "80px";
            el.innerHTML= "Read more...";
        }


    *** №2 Debugger - останавливает работу программы в том месте где в коде находится debugger. Нажав кнопку появившуюся на странице
                    можно его пропустить.

    function showText(el) {
        debugger;
        if(el.previousElementSibling.clientHeight === 80){
            el.previousElementSibling.style.height = "100%";
            el.innerHTML= "Show less";
        } else {
            el.previousElementSibling.style.height = "80px";
            el.innerHTML= "Read more...";
        }


    *** №3 alert() - можно не открывать консоль. Видно сообщение при срабатывании ф-и и она не может отработать пока не закроем окно.

    function showText(el) {
        alert("I'm inside!");
        if(el.previousElementSibling.clientHeight === 80){
            el.previousElementSibling.style.height = "100%";
            el.innerHTML= "Show less";
        } else {
            el.previousElementSibling.style.height = "80px";
            el.innerHTML= "Read more...";
        }

*/}


// ================================================  That's all folks  ========================================================